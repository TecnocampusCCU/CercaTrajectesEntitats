# -*- coding: utf-8 -*-
"""
/***************************************************************************
 CercaTrajectesEntitats
                                 A QGIS plugin
 CercaTrajectesEntitats
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2018-06-13
        git sha              : $Format:%H$
        copyright            : (C) 2018 by Josep LÃ³pez
        email                : jlopez@tecnocampus.cat
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import sys
import os
# import processing
from qgis import processing
from os.path import expanduser
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtWidgets import QAction,QMessageBox,QTableWidgetItem, QApplication, QToolBar
from qgis.core import QgsMapLayer
from qgis.core import QgsDataSourceUri
from qgis.core import QgsVectorLayer
from qgis.core import QgsFeatureRequest
from qgis.core import QgsField
from qgis.core import QgsPoint
from qgis.core import QgsPointXY
from qgis.core import QgsFeatureRenderer
from qgis.core import QgsVectorFileWriter
from qgis.core import QgsGraduatedSymbolRenderer
from qgis.core import QgsCategorizedSymbolRenderer
from qgis.core import QgsGradientColorRamp
from qgis.core import QgsProject
from qgis.core import QgsRendererRange
from qgis.core import QgsSymbol
from qgis.core import QgsFillSymbol
from qgis.core import QgsLineSymbol
from qgis.core import QgsSymbolLayerRegistry
from qgis.core import QgsRandomColorRamp
from qgis.core import QgsRendererRangeLabelFormat
from qgis.core import QgsProject
from qgis.core import QgsLayerTreeLayer
from qgis.core import QgsRenderContext
from qgis.core import QgsPalLayerSettings
from qgis.core import QgsTextFormat
from qgis.core import QgsTextBufferSettings
from qgis.core import QgsVectorLayerSimpleLabeling
from qgis.core import QgsWkbTypes
from qgis.core import QgsVectorLayerExporter
from qgis.core import QgsCoordinateReferenceSystem
from qgis.core import QgsFeature
from qgis.core import QgsGeometry

import psycopg2
import unicodedata
import datetime
import time
from qgis.utils import iface
from PyQt5.QtSql import *
import datetime
import time
import qgis.utils
import collections

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .CercaTrajectesEntitats_dialog import CercaTrajectesEntitatsDialog
import os.path
from itertools import dropwhile

"""
Variables globals per a la connexio
i per guardar el color dels botons
"""
Versio_modul="V_Q3.240515"
nomBD1=""
contra1=""
host1=""
port1=""
usuari1=""
schema=""
Fitxer=""
cur=None
conn=None
progress=None
aux=False
itemSel=None
lbl_Cost = ''
TEMPORARY_PATH=""
versio_db = ""

class CercaTrajectesEntitats:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'CercaTrajectesEntitats_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)

        # Create the dialog (after translation) and keep reference
        self.dlg = CercaTrajectesEntitatsDialog()
        
        self.dlg.bt_sortir.clicked.connect(self.on_click_Sortir)
        self.dlg.bt_inici.clicked.connect(self.on_click_Inici)
        self.dlg.bt_delete.clicked.connect(self.on_click_DeleteText)
        self.dlg.comboConnexio.currentIndexChanged.connect(self.on_Change_ComboConn)
        self.dlg.txt_nomCarrer.textChanged.connect(self.cercaDescipcioAux)
        self.dlg.bttnProper.clicked.connect(self.on_click_Proper)
        self.dlg.bttnProperParell.clicked.connect(self.on_click_ProperParell)
        self.dlg.list_carrers.itemDoubleClicked.connect(self.showItem)
        self.dlg.comboCost.currentIndexChanged.connect(self.changeComboCost)
        self.dlg.comboLeyenda.currentIndexChanged.connect(self.on_Change_ComboLeyenda)
        self.dlg.bt_ReloadLeyenda.clicked.connect(self.cerca_elements_Leyenda)

        

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr('&CCU')
        # TODO: We are going to let the user set this up in a future iteration
        #self.toolbar = self.iface.addToolBar('CCU')
        #self.toolbar.setObjectName('CercaTrajectesEntitats')
        
        trobat=False
        for x in iface.mainWindow().findChildren(QToolBar,'CCU'): 
            self.toolbar = x
            trobat=True
        
        if not trobat:
            self.toolbar = self.iface.addToolBar('CCU')
            self.toolbar.setObjectName('CCU')
        

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('CercaTrajectesEntitats', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/CercaTrajectesEntitats/icon.png'
        self.add_action(
            icon_path,
            text=self.tr('Cerca Trajectes Entitats'),
            callback=self.run,
            parent=self.iface.mainWindow())


    def on_click_Sortir(self):
        '''
        Tanca la finestra del plugin 
        '''
        self.estatInicial()
        self.dlg.close()
        
    def getConnections(self):
        """Aquesta funcio retorna les connexions que estan guardades en el projecte."""
        s = QSettings() 
        s.beginGroup("PostgreSQL/connections")
        currentConnections = s.childGroups()
        s.endGroup()
        return currentConnections
    
    def populateComboBox(self,combo,list,predef,sort):
        """Procediment per omplir el combo especificat amb la llista suministrada"""
        combo.blockSignals (True)
        combo.clear()
        model=QStandardItemModel(combo)
        predefInList = None
        for elem in list:
            try:
                item = QStandardItem(str(elem))
            except TypeError:
                item = QStandardItem(str(elem))
            model.appendRow(item)
            if elem == predef:
                predefInList = elem
        if sort:
            model.sort(0)
        combo.setModel(model)
        if predef != "":
            if predefInList:
                combo.setCurrentIndex(combo.findText(predefInList))
            else:
                combo.insertItem(0,predef)
                combo.setCurrentIndex(0)
        combo.blockSignals (False)
        
    def on_click_Proper(self, clicked):
        '''
        Aquesta funcio modifica l'aparenÃ§a dels botons 'Proper' i 'Proper Senar/Parell'
        quan el primer Ã©s pitjat
        '''
        if clicked:
            self.setButtonChecked(self.dlg.bttnProper)
            self.setButtonUnchecked(self.dlg.bttnProperParell)
        else:
            self.setButtonChecked(self.dlg.bttnProperParell)
            self.setButtonUnchecked(self.dlg.bttnProper)
            
    def on_click_ProperParell(self, clicked):
        '''
        Aquesta funcio modifica l'aparenÃ§a dels botons 'Proper' i 'Proper Senar/Parell'
        quan el segon Ã©s pitjat
        '''
        if clicked:
            self.setButtonChecked(self.dlg.bttnProperParell)
            self.setButtonUnchecked(self.dlg.bttnProper)
        else:
            self.setButtonChecked(self.dlg.bttnProper)
            self.setButtonUnchecked(self.dlg.bttnProperParell)
            
    def setButtonChecked(self, boto):
        '''
        FunciÃ³ auxiliar per canviar aparenÃ§a de botons
        '''
        boto.setChecked(True)
        boto.setStyleSheet('background-color: rgb(85, 255, 127)')
        
    def setButtonUnchecked(self, boto):
        '''
        FunciÃ³ auxiliar per canviar aparenÃ§a de botons
        '''
        boto.setChecked(False)
        boto.setStyleSheet('background-color: rgb(255, 156, 156)')
        
        
        
    def on_Change_ComboConn(self):
        """
        En el moment en que es modifica la opcio escollida 
        del combo o desplegable de les connexions,
        automÃ ticament comprova si es pot establir
        connexiÃ³ amb la bbdd seleccionada.
        """
        global aux
        global nomBD1
        global contra1
        global host1
        global port1
        global usuari1
        global schema
        global cur
        global conn
        s = QSettings()
        self.dlg.comboCapaDesti.clear()
        self.dlg.comboLeyenda.clear()
        self.dlg.comboGraf.clear()
        self.dlg.comboLletra.clear()
        self.dlg.txt_nomCarrer.clear()
        self.dlg.txt_Numero.clear()
        self.dlg.list_carrers.clear()
        select = 'Selecciona connexiÃ³'
        nom_conn=self.dlg.comboConnexio.currentText()
        
        
        if nom_conn != select:
            aux = True
            s.beginGroup("PostgreSQL/connections/"+nom_conn)
            currentKeys = s.childKeys()
            
            nomBD1 = s.value("database", "" )
            contra1 = s.value("password", "" )
            host1 = s.value("host", "" )
            port1 = s.value("port", "" )
            usuari1 = s.value("username", "" )
            schema= 'public'
            
            self.barraEstat_connectant()
            self.dlg.lblEstatConn.setAutoFillBackground(True)
            QApplication.processEvents()

            #Connexio
            nomBD = nomBD1.encode('ascii','ignore')
            usuari = usuari1.encode('ascii','ignore')
            servidor = host1.encode('ascii','ignore')     
            contrasenya = contra1.encode('ascii','ignore')
            try:
                estructura = "dbname='"+ nomBD.decode("utf-8") + "' user='" + usuari.decode("utf-8") +"' host='" + servidor.decode("utf-8") +"' password='" + contrasenya.decode("utf-8") + "'"# schema='"+schema+"'"
                conn = psycopg2.connect(estructura)
                self.barraEstat_connectat()
                cur = conn.cursor()
                
                sql = "select g.f_table_name from geometry_columns g join information_schema.columns c on g.f_table_name = c.table_name where g.type = 'POINT' and g.f_table_schema ='public' and c.table_schema ='public' and c.column_name like 'name%'order by 1"
                cur.execute(sql)
                llista = cur.fetchall()
                self.ompleCombos(self.dlg.comboCapaDesti, llista, 'Selecciona una entitat', True)
                self.ompleLletra()
                sql2 = "select f_table_name from geometry_columns where ((type = 'MULTILINESTRING' or type = 'LINESTRING') and f_table_schema ='public') order by 1"
                cur.execute(sql2)
                llista2 = cur.fetchall()
                self.ompleCombos(self.dlg.comboGraf, llista2, 'Selecciona una entitat', True)
                
                self.cerca_elements_Leyenda()
                
                
            except Exception as ex:
                print ("I am unable to connect to the database")
                template = "An exception of type {0} occurred. Arguments:\n{1!r}"
                message = template.format(type(ex).__name__, ex.args)
                print (message)
                QMessageBox.information(None, "Error", "Error canvi connexiÃ³")
                conn.rollback()
                self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #ff7f7f')
                self.dlg.lblEstatConn.setText('Error: Hi ha algun camp erroni.')
                return
            
            try:
                self.cercaDescripcio()
            except Exception as ex:
                print ("DescripciÃ³ no  funciona!")
                template = "An exception of type {0} occurred. Arguments:\n{1!r}"
                message = template.format(type(ex).__name__, ex.args)
                print (message)
                QMessageBox.information(None, "Error", "Error canvi connexiÃ³")
                conn.rollback
                return
        else:
            aux = False
            self.barraEstat_noConnectat()
            
    def detect_database_version(self):
        global cur
        global conn
        global versio_db

        sql_versio = "select taula from config where variable = 'versio';"
        cur.execute(sql_versio)
        versio_db = cur.fetchone()[0]

        if versio_db == '1.0':
            try:
                sql = "select taula from config where variable = 'carrers';"
                cur.execute(sql)
                carrers_name = cur.fetchone()[0]
                sql = "SELECT taula FROM config WHERE variable = 'portals';"
                cur.execute(sql)
                portals_name = cur.fetchone()[0]
                sql = "SELECT taula FROM config WHERE variable = 'xarxa';"
                cur.execute(sql)
                xarxa_name = cur.fetchone()[0]
            except:
                print("Error al llegir la configuraciÃ³ de la base de dades")
                QMessageBox.information(None, "Error", "Error al llegir la configuraciÃ³ de la base de dades")
                return
            try:
                cur.execute(f"""
                            DROP TABLE IF EXISTS thoroughfare;
                            CREATE LOCAL TEMP TABLE thoroughfare (
                                id,
                                type,
                                name
                            ) AS SELECT "id", "Tipus", "Nom" FROM "{carrers_name}";
                            """)
                conn.commit()
                cur.execute(f"""
                            DROP TABLE IF EXISTS address;
                            CREATE LOCAL TEMP TABLE address (
                                id_address,
                                geom,
                                cadastral_reference,
                                designator
                            ) AS SELECT id, geom, "REF_CADAST", "Carrer_Num_Bis" FROM "{portals_name}";
                            """)
                conn.commit()
                cur.execute(f"""
                            DROP TABLE IF EXISTS stretch;
                            CREATE LOCAL TEMP TABLE stretch (
                                id,
                                cost,
                                reverse_cost,
                                semaphores,
                                total_cost_semaphore,
                                geom,
                                source,
                                target,
                                length,
                                direction,
                                slope_abs,
                                speed,
                                reverse_speed
                            ) AS SELECT "id", "cost", "reverse_cost", "Nombre_Semafors", "Cost_Total_Semafor_Tram", "the_geom", "source", "target", "LENGTH", "SENTIT"::INTEGER, "PENDENT_ABS", "VELOCITAT_PS", "VELOCITAT_PS_INV" FROM "{self.dlg.comboGraf.currentText()}";
                            """)
                conn.commit()
            except:
                print("Error al crear les taules temporals")
                QMessageBox.information(None, "Error", "Error al crear les taules temporals")
                return
        else:
            try:
                sql = "DROP TABLE IF EXISTS parcel_temp;\n"
                sql += "CREATE TABLE parcel_temp AS SELECT * FROM parcel;"
                cur.execute(sql)
                conn.commit()
            except:
                print("Error al crear la taula temporal")
                QMessageBox.information(None, "Error", "Error al crear la taula temporal")
                return
    
    def cerca_elements_Leyenda(self):
        
        if self.dlg.comboConnexio.currentText() != 'Selecciona connexiÃ³':
            try: #Accedir als elements de la llegenda que siguin de tipus punt.
                aux = []
                layers = QgsProject.instance().mapLayers().values()
                for layer in layers:
                    #print(layer.type())
                    if layer.type()==QgsMapLayer.VectorLayer:
                        if layer.wkbType()==QgsWkbTypes.Point:
                            aux.append(layer.name())
                        
                self.ompleCombos(self.dlg.comboLeyenda, aux, 'Selecciona una entitat', True)
            except Exception as ex:
                missatge="Error al afegir els elements de la llegenda"
                print (missatge)
                template = "An exception of type {0} occurred. Arguments:\n{1!r}"
                message = template.format(type(ex).__name__, ex.args)
                print (message)
                QMessageBox.information(None, "Error", missatge)
                return
    
    def showItem(self):
        '''
        FunciÃ³ que posa el nom del carrer al camp de cerca de carrer quan es fa doble-click
        a un element de la llista 
        '''
        global itemSel
        itemSel=self.dlg.list_carrers.selectedItems()[0].toolTip()
        self.dlg.txt_nomCarrer.setText(self.dlg.list_carrers.selectedItems()[0].text())
            
    def ompleLletra(self):
        '''
        Aquesta funciÃ³ omple el desplegable de lletres amb totes les opcions possibles:
        totes les lletres que figuren en l'Ãºltim caracter del Carrer_Num_Bis de la 
        capa de dintreilla
        '''
        global conn
        global cur
        self.dlg.comboLletra.clear()
        sql = "SELECT * from (select distinct(upper(right(\"designator\",1))) from \"address\" order by 1) consulta where \"upper\"  not in  ('0','1', '2', '3','4','5','6','7','8','9');"
        cur.execute(sql)
        rows = cur.fetchall()
        self.ompleCombos(self.dlg.comboLletra, rows, ' ', True)
    
    def cercaDescipcioAux(self):
        '''
        FunciÃ³ auxiliar que evita un problema amb la connexiÃ³ quan
        s'executa el plugin de nou: en el cas que no hi hagi cap connexiÃ³,
        no permet que es faci cap cerca
        '''
        global aux
        if aux:
            self.cercaDescripcio()
    
    def cercaDescripcio(self):
        """Aquesta funcio cerca els carrers que continguin la paraula clau que li passem"""
        global cur
        global conn        #Sentencia SQL
        self.dlg.list_carrers.clear()
        #sql = 'select "Codi", "Tipus","Nom" from anterior."NOMENCLATOR"'
        sql = 'select code, type, name from thoroughfare'
        filtre=self.dlg.txt_nomCarrer.text().upper()
        
        filtre = filtre.replace("'", "''")
        wheresql=" WHERE \"name\" LIKE \'%"+filtre+"%\' order by 3;"
        total = sql + wheresql
        cur.execute(total)
        rows = cur.fetchall()
        for index,row in enumerate(rows,start=0):
            if row[1] is None:
                desc=str(row[2])
            else:
                desc=str(row[1]) + " " + str(row[2])
            self.dlg.list_carrers.addItem(desc)
            self.dlg.list_carrers.item(index).setToolTip(str(row[0]))
            
    def ompleCombos(self, combo, llista, predef, sort):
        """Aquesta funciÃ³ omple els combos que li passem per parÃ metres"""
        combo.blockSignals (True)
        combo.clear()
        model=QStandardItemModel(combo)
        predefInList = None
        for elem in llista:
            try:
                if isinstance(elem, tuple):
                    item = QStandardItem(str(elem[0]))
                    #item = QStandardItem(unicode(elem[0]))
                else:
                    item = QStandardItem(str(elem))
            except TypeError:
                item = QStandardItem(str(elem[0]))
            model.appendRow(item)
            if elem == predef:
                predefInList = elem
        combo.setModel(model)
        if predef != "":
            if predefInList:
                combo.setCurrentIndex(combo.findText(predefInList))
            else:
                combo.insertItem(0,predef)
                combo.setCurrentIndex(0)
        combo.blockSignals (False)
        
    def changeComboCost(self):
        """Aquesta funciÃ³ controla el canvi d'opciÃ³ del comboBox del mÃ¨tode treball."""
        global lbl_Cost
        dist = 'Distancia'
        temps = 'Temps'
        nom_metode=self.dlg.comboCost.currentText()
        if dist == nom_metode:
            self.dlg.chk_CostNusos.setEnabled(False)
            self.dlg.chk_CostNusos.setChecked(False)
            lbl_Cost = 'DistÃ ncia (m)'
            self.dlg.chk_Local.setEnabled(True)
            self.dlg.chk_Local.setChecked(True)
        else:
            self.dlg.chk_CostNusos.setEnabled(True)
            lbl_Cost = 'Temps (min)'
            self.dlg.chk_Local.setEnabled(True)
            self.dlg.chk_Local.setChecked(True)
        
    def estatInicial(self):
        '''
        @param self:
        Resteja tots els valors per defecte del plugin: estat inicial.
        '''
        global aux
        global Versio_modul
        global itemSel
        global lbl_Cost
        global TEMPORARY_PATH
        aux = False
        itemSel = None
        self.dlg.comboLletra.clear()
        self.dlg.comboLeyenda.clear()
        self.dlg.comboGraf.clear()
        self.barraEstat_noConnectat()
        self.dlg.list_carrers.clear()
        self.dlg.txt_nomCarrer.clear()
        self.dlg.comboCapaDesti.clear()
        self.dlg.taulaResultat.clear()
        self.eliminaTaula()
        self.dlg.txt_Numero.clear()
        self.dlg.versio.setText(Versio_modul)
        self.setButtonChecked(self.dlg.bttnProper)
        self.setButtonUnchecked(self.dlg.bttnProperParell)
        self.dlg.SB_camins.setValue(3)
        self.dlg.lbl_numpol.setText('')
        self.dlg.comboCost.setCurrentIndex(0)
        self.dlg.chk_CostNusos.setEnabled(False)
        self.dlg.chk_CostNusos.setChecked(False)
        self.dlg.chk_Local.setEnabled(True)
        self.dlg.chk_Local.setChecked(False)
        lbl_Cost = 'DistÃ ncia (m)'
        self.dlg.chk_Local.setChecked(True)
        self.dlg.chk_Local.setEnabled(True)
        self.dlg.tabWidget_Destino.setCurrentIndex(0)
        self.dlg.setEnabled(True)
        if (os.name=='nt'):
            TEMPORARY_PATH=os.environ['TMP']
        else:
            TEMPORARY_PATH=os.environ['TMPDIR']
    
    def on_Change_ComboGraf(self, state):
        """
        En el moment en que es modifica la opcio escollida 
        del combo o desplegable de la capa de punts,
        automÃÂ ticament comprova els camps de la taula escollida.
        """
        try:
            capa=self.dlg.comboGraf.currentText()
            if capa != "":
                if capa != 'Selecciona una entitat':
                    if (self.grafValid(capa)):
                        pass
                    else:
                        QMessageBox.information(None, "Error", 'El graf seleccionat no tÃ© la capa de nusos corresponent.\nEscolliu un altre.')
        except Exception as ex:
            print ("Error Graf seleccionat")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            QMessageBox.information(None, "Error", "Error Graf seleccionat")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.bar.clearWidgets()
            self.dlg.lblEstatConn.setText('Connectat')
            self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
            return "ERROR"
    
    
    def controlErrorsInput(self):
        '''
        Aquesta funciÃ³ s'encarrega de controlar que quan comenci el cÃ lcul
        totes les entrades de dades estiguin omplertes i siguin correctes
        '''
        global itemSel
        errors = []
        if self.dlg.comboConnexio.currentText() == 'Selecciona connexiÃ³':
            errors.append("No hi ha connexiÃ³")
        try:
            numero = int(float(self.dlg.txt_Numero.text()))
            if numero < 0:
                errors.append("El nÃºmero de policia no pot ser negatiu")
        except:
            errors.append("El nÃºmero de policia no Ã©s vÃ lid")
        if itemSel == None:
            errors.append('El carrer de la llista no estÃ  correctament seleccionat')
        if self.dlg.comboCapaDesti.currentText() == '':
            errors.append('No hi ha cap capa de destÃ­ disponible')
        if self.dlg.comboGraf.currentText() == 'Selecciona una entitat':
            errors.append("No hi ha seleccionada cap capa de xarxa")
        if self.dlg.tabWidget_Destino.currentIndex() == 0:
            if self.dlg.comboCapaDesti.currentText() == 'Selecciona una entitat':
                errors.append('No hi ha cap capa de destÃ­ seleccionada')
        else:
            if self.dlg.comboLeyenda.currentText() == 'Selecciona una entitat':
                errors.append('No hi ha cap capa de destÃ­ seleccionada')
        return errors
    
    def comprovaCNB(self,CNB,carrer,numero,lletra):
        '''
        Aquest funciÃ³ s'encarrega de trobar el 'Carrer_Num_Bis' exacte o mÃ©s proper
        al que l'usuari ha demanat en el formulari
        '''
        global cur
        global conn
        '''
        Primer comprova si el CNB que ha passat l'usuari existeix:
            Si existeix el retorna com a vÃ lid
            Altrament busca el mÃ©s proper: Si no en troba cap de vÃ lid, emet un error
        '''
        select = 'select count(*) from "address" where "designator" = \''+ CNB + '\';'
        cur.execute(select)
        resultat = cur.fetchall()
        if (int(float(resultat[0][0])) >= 1):
            return CNB
        else:
            create = 'drop table if exists checkNum;\n'
            if self.dlg.bttnProper.isChecked():
                create += 'create local temp table checkNum as select nullif(SUBSTRING ( "designator" ,6 , 3 ), \'\') ::int as numero from "address" where "designator" like \'' + carrer +'%\' order by 1;'
            elif self.dlg.bttnProperParell.isChecked():
                if ((int(float(numero))%2)  == 0):
                    create += 'create local temp table checkNum as select * from (select nullif(SUBSTRING ( "designator" ,6 , 3 ), \'\') ::int as numero from "address" where "designator" like \'' + carrer +'%\' order by 1) as num where numero%2 = 0;'
                else:
                    create += 'create local temp table checkNum as select * from (select nullif(SUBSTRING ( "designator" ,6 , 3 ), \'\') ::int as numero from "address" where "designator" like \'' + carrer +'%\' order by 1) as num where numero%2 = 1;'
                
            select = 'SELECT * FROM\n'
            select += '((SELECT numero FROM checkNum WHERE numero >= '+ str(int(float(numero))) +' ORDER BY numero LIMIT 1)  UNION\n'
            select += '(SELECT numero FROM checkNum WHERE numero < '+ str(int(float(numero))) +' ORDER BY numero DESC LIMIT 1))  as limitat\n'
            select += 'ORDER BY abs('+ str(int(float(numero))) +'-numero) LIMIT 1;'
            
            cur.execute(create)
            conn.commit()
            
                
            count_select = 'select count(*) from checkNum;'
            cur.execute(count_select)
            resultat = cur.fetchall()
            if int(float(resultat[0][0])) == 0:
                return '-1'

                
            cur.execute(select)
            resultat = cur.fetchall()
            nouNumero = resultat[0][0]
            if int(float(resultat[0][0])) < 100:
                nouNumero = '0' + str(resultat[0][0])
            if int(float(resultat[0][0])) < 10:
                nouNumero = '00' + str(resultat[0][0])

            
            CNBsenseLletra = carrer + str(nouNumero)
            select = 'select count(*) from "address" where "designator" = \''+ CNBsenseLletra + 'x\';'
            cur.execute(select)
            resultat = cur.fetchall()
            if (int(float(resultat[0][0])) >= 1):
                return (CNBsenseLletra + 'x')
            else:
                select = 'select SUBSTRING ( "designator" ,9 , 1 )as lletra from "address" where "designator" like \''+ CNBsenseLletra +'%\' order by 1;'
                cur.execute(select)
                resultat = cur.fetchall()
                return (CNBsenseLletra + str(resultat[0][0]))
            
    def on_click_DeleteText(self):
        global itemSel
        '''
        Aquesta funciÃ³ s'encarrega d'esborrar el text de cerca quan es prem el botÃ³ amb una creu 'X'
        contigu a la barra de cerca de carrers.
        '''
        self.dlg.txt_nomCarrer.clear()
        itemSel = None
        
    def comprobarValidez(self,vlayer,CRS):        
        #processing.algorithmHelp("native:shortestpathpointtolayer")
        epsg = CRS
        
        alg_params = {
            'INPUT': vlayer,
            'OPERATION': '',
            'TARGET_CRS': QgsCoordinateReferenceSystem('EPSG:'+str(epsg)),
            'OUTPUT': 'memory:'
        }
        layer_repro = processing.run('native:reprojectlayer', alg_params)

        parameters= {'ERROR_OUTPUT' : 'memory:',
                     #'IGNORE_RING_SELF_INTERSECTION' : False,
                     'INPUT_LAYER' : layer_repro['OUTPUT'],
                     'INVALID_OUTPUT' : 'memory:',
                     'METHOD' : 1,
                     'VALID_OUTPUT' : 'memory:'}
        
        result = processing.run('qgis:checkvalidity',parameters)
        
        return result['VALID_OUTPUT']
        
    def calculo_Local(self,network_lyr,CNB,uri2,start_point,end_lyr):        
        #processing.algorithmHelp("native:shortestpathpointtolayer")
        if self.dlg.comboCost.currentText() != 'Distancia':
            network_lyr = self.calcul_graf3(network_lyr,start_point,uri2,end_lyr)
            
            parameters= {'INPUT':network_lyr,
                         'STRATEGY':1, 
                         'DIRECTION_FIELD': 'DIRECCIO',
                         'VALUE_FORWARD': 'D',
                         'VALUE_BACKWARD': '',
                         'VALUE_BOTH': '',
                         'DEFAULT_DIRECTION':0,
                         'SPEED_FIELD': 'VEL_KMH',
                         'DEFAULT_SPEED':50,
                         'TOLERANCE':0.1,
                         'START_POINT':start_point,
                         'END_POINTS':end_lyr,
                         'OUTPUT':'memory:'}
        
        else:
            parameters= {'INPUT':network_lyr,
                         'STRATEGY':0, 
                         'DIRECTION_FIELD': '',
                         'VALUE_FORWARD': '',
                         'VALUE_BACKWARD': '',
                         'VALUE_BOTH': '',
                         'DEFAULT_DIRECTION':2,
                         'SPEED_FIELD': '',
                         'DEFAULT_SPEED':1,
                         'TOLERANCE':0,
                         'START_POINT':start_point,
                         'END_POINTS':end_lyr,
                         'OUTPUT':'memory:'}
        Result=processing.run('native:shortestpathpointtolayer',parameters)

        if self.dlg.comboCost.currentText() != 'Distancia':
            # Passo el agg_cost de hores a minuts
            alg_params = {
                'FIELD_LENGTH': 10,
                'FIELD_NAME': 'cost',
                'FIELD_PRECISION': 1,
                'FIELD_TYPE': 0,
                'FORMULA': 'round(\"cost\"*60,1)',
                'INPUT': Result['OUTPUT'],
                'NEW_FIELD': False,
                'OUTPUT': 'memory:'
            }
            return processing.run('qgis:fieldcalculator', alg_params)        
        else:
            return Result
    def troba_distancia(self,linea,punt):
        distancia=linea.geometry().lineLocatePoint(punt.geometry())
        return distancia
    def troba_posicio(self,id,llista_id):
        resultat=[]
        for j,x in enumerate(llista_id):
            #print (x)
            if id==x:
                #print ("id:"+str(id))
                resultat.append(j)
        return resultat
        
    def calcula_distancies(self,linea,posicio,punts):
        resultat=[]
        for i in range(len(posicio)):
            #print (posicio[i])
            resultat.append([posicio[i],self.troba_distancia(linea,punts[posicio[i]])])
        resultat=sorted(resultat, key=lambda x: x[1])
        return resultat
    
    def Calcula_VEL_KMH(self,xarxa,crs,uri):
         # Invertir direcciÃ³n de lÃ­nea
        alg_params = {
        'INPUT': xarxa,
        'OUTPUT': 'memory:'
        }
        outputs={}
        outputs['InvertirDireccinDeLnea'] = processing.run('native:reverselinedirection', alg_params)
        
        #True perque sempre es farÃ  servir el cost invers
        if (True): #(self.dlg.chk_CostInvers.isChecked()):

            # VEL_PS=0
            alg_params = {
                'FIELD_LENGTH': 10,
                'FIELD_NAME': 'speed',
                'FIELD_PRECISION': 9,
                'FIELD_TYPE': 0,
                'FORMULA': '0*0',
                'INPUT': outputs['InvertirDireccinDeLnea']['OUTPUT'],
                'NEW_FIELD': False,
                'OUTPUT': 'memory:'
            }
            outputs['Vel_ps0'] = processing.run('qgis:fieldcalculator', alg_params)
    
            # VEL_PS_INV=0
            alg_params = {
                'FIELD_LENGTH': 10,
                'FIELD_NAME': 'reverse_speed',
                'FIELD_PRECISION': 9,
                'FIELD_TYPE': 0,
                'FORMULA': '0*0',
                'INPUT': xarxa,
                'NEW_FIELD': False,
                'OUTPUT': 'memory:'
            }
            outputs['Vel_ps_inv0'] = processing.run('qgis:fieldcalculator', alg_params)
        
           # CREACIO_VEL_KMH_INV
            alg_params = {
                'FIELD_LENGTH': 10,
                'FIELD_NAME': 'VEL_KMH',
                'FIELD_PRECISION': 9,
                'FIELD_TYPE': 0,
                'FORMULA': '\"reverse_speed\"*60/1000',
                'INPUT': outputs['Vel_ps0']['OUTPUT'],
                'NEW_FIELD': False,
                'OUTPUT': 'memory:'
            }
            outputs['Creacio_vel_kmh_inv'] = processing.run('qgis:fieldcalculator', alg_params)
        
            # CREACIO_VEL_KMH_DIREC
            alg_params = {
                'FIELD_LENGTH': 10,
                'FIELD_NAME': 'VEL_KMH',
                'FIELD_PRECISION': 9,
                'FIELD_TYPE': 0,
                'FORMULA': 'speed*60/1000',
                'INPUT': outputs['Vel_ps_inv0']['OUTPUT'],
                'NEW_FIELD': True,
                'OUTPUT': 'memory:'
            }
            outputs['Creacio_vel_kmh_direc'] = processing.run('qgis:fieldcalculator', alg_params)
                    
        else:
            # VEL_PS=0
            alg_params = {
                'FIELD_LENGTH': 10,
                'FIELD_NAME': 'reverse_speed',
                'FIELD_PRECISION': 9,
                'FIELD_TYPE': 0,
                'FORMULA': '0*0',
                'INPUT': outputs['InvertirDireccinDeLnea']['OUTPUT'],
                'NEW_FIELD': False,
                'OUTPUT': 'memory:'
            }
            outputs['Vel_ps0'] = processing.run('qgis:fieldcalculator', alg_params)
    
            # VEL_PS_INV=0
            alg_params = {
                'FIELD_LENGTH': 10,
                'FIELD_NAME': 'reverse_speed',
                'FIELD_PRECISION': 9,
                'FIELD_TYPE': 0,
                'FORMULA': '0*0',
                'INPUT': xarxa,
                'NEW_FIELD': False,
                'OUTPUT': 'memory:'
            }
            outputs['Vel_ps_inv0'] = processing.run('qgis:fieldcalculator', alg_params)
        
           # CREACIO_VEL_KMH_INV
            alg_params = {
                'FIELD_LENGTH': 10,
                'FIELD_NAME': 'VEL_KMH',
                'FIELD_PRECISION': 9,
                'FIELD_TYPE': 0,
                'FORMULA': '\"speed\"*60/1000',
                'INPUT': outputs['Vel_ps0']['OUTPUT'],
                'NEW_FIELD': False,
                'OUTPUT': 'memory:'
            }
            outputs['Creacio_vel_kmh_inv'] = processing.run('qgis:fieldcalculator', alg_params)
        
            # CREACIO_VEL_KMH_DIREC
            alg_params = {
                'FIELD_LENGTH': 10,
                'FIELD_NAME': 'VEL_KMH',
                'FIELD_PRECISION': 9,
                'FIELD_TYPE': 0,
                'FORMULA': 'speed*60/1000',
                'INPUT': outputs['Vel_ps_inv0']['OUTPUT'],
                'NEW_FIELD': True,
                'OUTPUT': 'memory:'
            }
            outputs['Creacio_vel_kmh_direc'] = processing.run('qgis:fieldcalculator', alg_params)
        
        # Unir capas vectoriales
        alg_params = {
            'CRS': QgsCoordinateReferenceSystem('EPSG:'+str(crs)),
            'LAYERS': [outputs['Creacio_vel_kmh_direc']['OUTPUT'],outputs['Creacio_vel_kmh_inv']['OUTPUT']],
            'OUTPUT': 'memory:'
        }
        outputs['UnirCapasVectoriales'] = processing.run('native:mergevectorlayers', alg_params)
    
        # DIRECCIO
        alg_params = {
            'FIELD_LENGTH': 10,
            'FIELD_NAME': 'DIRECCIO',
            'FIELD_PRECISION': 3,
            'FIELD_TYPE': 2,
            'FORMULA': '\'D\'',
            'INPUT': outputs['UnirCapasVectoriales']['OUTPUT'],
            'NEW_FIELD': True,
            'OUTPUT': 'memory:'
        }
        outputs['Direccio'] = processing.run('qgis:fieldcalculator', alg_params)

        if (self.dlg.chk_CostNusos.isChecked()):
            # CREACIO_L_TRAM_TEMP
            alg_params = {
                'FIELD_LENGTH': 10,
                'FIELD_NAME': 'L_TRAM_TEMP',
                'FIELD_PRECISION': 9,
                'FIELD_TYPE': 0,
                'FORMULA': '$length',
                'INPUT': outputs['Direccio']['OUTPUT'],
                'NEW_FIELD': True,
                'OUTPUT': 'memory:'
            }
            outputs['Direccio'] = processing.run('qgis:fieldcalculator', alg_params)        
        return outputs['Direccio']['OUTPUT']
                
        #print (outputs)
    
    #def calcul_graf3(self,sql_punts,sql_xarxa,uri2):
    def calcul_graf3(self,network_lyr,start_point,uri2,punts_finals):
        #               *****************************************************************************************************************
        #               INICI CARREGA DE LES ILLES, PARCELES O PORTALS QUE QUEDEN AFECTATS PEL BUFFER DEL GRAF 
        #               *****************************************************************************************************************
        #                uri.setDataSource("","("+sql_total+")","geom","","id")
        global Fitxer

        #if (punts_lyr.isValid() and network_lyr.isValid()):
        #************************************************************************************
        #************************************************************************************
        outputs = {}
        epsg = network_lyr.crs().postgisSrid()
        '''
        alg_params = {
            'INPUT': start_point,
            'OUTPUT': 'memory:'
        }
        
        punt_reproy = processing.run('native:pointtolayer', alg_params)  
        punts_lyr=punt_reproy['OUTPUT']      
        '''
        
        punts_lyr = QgsVectorLayer("Point?crs=epsg:" + str(epsg), "Punt", "memory")
        # add a feature
        fet = QgsFeature() #QgsGeometry.fromPointXY(minDistPoint)
        coord=start_point.split(", ")

        #print(coord[1])
        fet.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(float(coord[0]),float(coord[1]))))        
        punts_lyr.dataProvider().addFeature(fet)
        punts_finals_features=punts_finals.getFeatures()

        #Afegir els punts_finals a la entitat punts_lyr per tallar el graf.
        for punt_final in punts_finals_features:
            geom = punt_final.geometry()
            fet.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(float(QgsPointXY(geom.asPoint()).x()),float(QgsPointXY(geom.asPoint()).y()))))        
            punts_lyr.dataProvider().addFeature(fet)
        
        
        punts_lyr.updateExtents()
        #QgsProject.instance().addMapLayer(punts_lyr)
        
        
        alg_params = {
            'INPUT': punts_lyr,
            'OPERATION': '',
            'TARGET_CRS': QgsCoordinateReferenceSystem('EPSG:'+str(epsg)),
            'OUTPUT': 'memory:'
        }
        outputs['ReproyectarCapa'] = processing.run('native:reprojectlayer', alg_params)
        
        
        p_lyr = outputs['ReproyectarCapa']['OUTPUT']
        graf = network_lyr
        

        l_lyr=self.Calcula_VEL_KMH(graf,epsg,uri2)
        
        #QgsProject.instance().addMapLayer(l_lyr)
        

        
        lines_features = [ line_feature for line_feature in l_lyr.getFeatures() ] 
        points_features = [ point_feature for point_feature in p_lyr.getFeatures() ]
        vl = QgsVectorLayer("LineString?crs=epsg:" + str(epsg), "Lineas2", "memory")
        pr = vl.dataProvider()
        lista=[]
        for field in lines_features[0].fields():
            lista.append(field)
        
        #print (lista)
        pr.addAttributes(lista)
            
        vl.updateFields()
        feats = []
        puntos=[]
        idx_lines=[]
        punts_id=[]
        Trams0_id=[]
        Trams1_id=[]
        Trams_id=[]
        repetits=[]
        for p in points_features:
            lineas=[]
            for l in lines_features:
                lineas.append([l.geometry().closestSegmentWithContext( p.geometry().asPoint() )])
            punts_id.append(min(lineas)[0][1])
            Trams0_id.append(lineas.index(sorted(lineas)[0])+1)
            Trams1_id.append(lineas.index(sorted(lineas)[1])+1)
        Trams_id.append([0,Trams0_id])
        Trams_id.append([1,Trams1_id])
        #print(Trams0_id)
        #print(Trams1_id)
        #print(Trams_id)
        #print(Trams_id[0][1])
        #print(Trams_id[1][1])
        
        repetits.append([x for x, y in collections.Counter(Trams_id[0][1]).items() if y > 1])
        repetits.append([x for x, y in collections.Counter(Trams_id[1][1]).items() if y > 1])
        #print(repetits)
        
        trams_fets=[]
        feat_temp = QgsFeature()
        for index_punt,p in enumerate(points_features):
            #print(index_punt)
            #print (repetits)
            for i in range(2):
                linea_cut=lines_features[Trams_id[i][1][index_punt]-1]
                if ([linea_cut.id()]) not in repetits:
                    idx_lines.append(linea_cut.id())
        
                    start=0
                    distancia=round(self.troba_distancia(linea_cut,p),3)
                    longitud=round(linea_cut.geometry().length(),3)
                    lp=linea_cut.geometry().constGet()
                    newgeom=QgsGeometry(lp.curveSubstring(start,distancia))
                    #print(newgeom)
                    f=QgsFeature()
                    f.setAttributes(linea_cut.attributes())
                    f.setGeometry(newgeom)
                    feats.append(f)
        
                    newgeom=QgsGeometry(lp.curveSubstring(distancia,longitud))
                    #print(newgeom)
                    f=QgsFeature()
                    f.setAttributes(linea_cut.attributes())
                    f.setGeometry(newgeom)
                    feats.append(f)
                else:
                    #print("REPE")
                    #break
                    id_tram_Read=linea_cut.id()
                    if id_tram_Read not in trams_fets:
                        trams_fets.append(id_tram_Read)
        
                        idx_lines.append(id_tram_Read)
                        posicio=self.troba_posicio(linea_cut.id(),Trams_id[i][1])
                        llista_dist=self.calcula_distancies(linea_cut,posicio,points_features)
                        #En llista_dist estan ordenat de menor distancia a major distancia
                        
                        #break
                        start=0
                        #distancia=troba_distancia(linea_cut,p)
                        longitud=round(linea_cut.geometry().length(),3)
                        #print (longitud)
                        lp=linea_cut.geometry().constGet()
                        for x in range(len(posicio)):
                            if x==0:
                                start=0
                            else:
                                start=round(llista_dist[x-1][1],3)
                            
                            distancia=round(llista_dist[x][1],3)
        
                            newgeom=QgsGeometry(lp.curveSubstring(start,distancia))
                            f=QgsFeature()
                            f.setAttributes(linea_cut.attributes())
                            f.setGeometry(newgeom)
                            feats.append(f)
        
                        newgeom=QgsGeometry(lp.curveSubstring(distancia,longitud))
                        f=QgsFeature()
                        f.setAttributes(linea_cut.attributes())
                        f.setGeometry(newgeom)
                        feats.append(f)
                        
                    #for x in range(Trams_id[i][1].count(lines_features[Trams_id[i][1][p.id()-1]-1].id())):
                        
            minDistPoint = punts_id[index_punt]
            punto = QgsFeature()
            punto.setGeometry(QgsGeometry.fromPointXY(minDistPoint))
        
            punto.setAttributes([points_features.index(p),123])
            puntos.append(punto)
            #print (trams_fets)
        for current,feat_item in enumerate(lines_features):
            if (current+1) not in idx_lines:
                feats.append(feat_item)
        pr.addFeatures(feats)
        vl.updateExtents()
        
        if (self.dlg.chk_CostNusos.isChecked()):

            # AFEGIR COST DE SEMAFORS A VEL_KMH
            
            alg_params = {
                'FIELD_LENGTH': 10,
                'FIELD_NAME': 'VEL_KMH',
                'FIELD_PRECISION': 9,
                'FIELD_TYPE': 0,
                'FORMULA': '($length /(($length/((\"speed\"+\"reverse_speed\")))+(\"total_cost_semaphore\"*($length/\"L_TRAM_TEMP\"))))*60/1000',
                'INPUT': vl,
                'NEW_FIELD': False,
                'OUTPUT': 'memory:'
                #'OUTPUT': 'postgres: table="public"."testpep" (geom) '+uri.connectionInfo()
            }
            outputs['vel_kmh_amb_sem'] = processing.run('qgis:fieldcalculator', alg_params)
            layer=outputs['vel_kmh_amb_sem']['OUTPUT']
        else:
            layer=vl
        
        
        return layer
    

        
    def save_vlayer(self,end_lyr):
        end_lyr.selectAll()
        parameters= {'INPUT':end_lyr,
                     'OUTPUT':'memory:'}
        
        return processing.run("native:saveselectedfeatures", parameters)
    
    
    def featureNotInResult(self,target,resultado):
        features = resultado.getFeatures()
        for feature in features:
            if(target['entitatid'] == feature['entitatid']):
                return False  
         
        return True
    
    
    def compareToGetOrdre(self,target,resultado):
        features = resultado.getFeatures()
        for feature in features:
            if(target['entitatid'] == feature['entitatid']):
                return feature['ordre']
        return 0
        
    def getIndexOrdre(self,vlayer):
        fields = vlayer.fields()
        for x in range(len(fields)):
            if(fields[x].displayName()=='ordre'):
                return x
        return -1
    
    
    
    def on_Change_ComboLeyenda(self):
        L_capa = self.dlg.comboLeyenda.currentText()

        if L_capa == '' or L_capa == 'Selecciona capa':
            return
        
        errors = self.controlEntitatLeyenda(L_capa) # retorna una llista amb aquells camps que no hi siguin

        if not 'id' in errors:
            alg_params = {
                'INPUT': L_capa,
                'FIELD_NAME': 'id',
                'FIELD_TYPE': 1,
                'FORMULA': '@id',
                'OUTPUT': 'memory:'
            }
            L_capa = processing.run("qgis:fieldcalculator", alg_params)['OUTPUT']
        return True
        
    def controlEntitatLeyenda(self,entitat):
        '''
        Aquest metode mira si la entitat rebuda te els camps (id, geom, Nom) retorna una llista amb aquells camps que hi siguin.
        '''
        global cur
        global conn
        list = []
        
        layers = QgsProject.instance().mapLayers().values()
        if layers != None:
            for layer in layers:
                if layer.type()==QgsMapLayer.VectorLayer:
                    if layer.sourceName() == entitat:
                        for each in layer.fields():
                            if each.name() == "id":
                                list.append("id")
                            elif each.name() == "available_places":
                                list.append("available_places")
                            elif each.name() == "radius":
                                list.append("radius")
                            elif each.name() == "name":
                                list.append("name")
        return list   
    
    
    def cerca_elements_Leyenda(self):
        
        if self.dlg.comboConnexio.currentText() != 'Selecciona connexiÃ³':
            try: #Accedir als elements de la llegenda que siguin de tipus punt.
                aux = []
                layers = QgsProject.instance().mapLayers().values()
                for layer in layers:
                    #print(layer.type())
                    if layer.type()==QgsMapLayer.VectorLayer:
                        if layer.wkbType()==QgsWkbTypes.Point:
                            aux.append(layer.name())
                        
                self.ompleCombos(self.dlg.comboLeyenda, aux, 'Selecciona una entitat', True)
            except Exception as ex:
                missatge="Error al afegir els elements de la llegenda"
                print (missatge)
                template = "An exception of type {0} occurred. Arguments:\n{1!r}"
                message = template.format(type(ex).__name__, ex.args)
                print (message)
                QMessageBox.information(None, "Error", missatge)
                return
    
    
    def on_click_Inici(self):
        '''
        FUNCIÃ DE CÃLCUL PRINCIPAL
        S'encarrega de fer el cÃ lcul de les N-entitats mÃ©s properes a l'adreÃ§a escollida per l'usuari
        i mostrar per pantalla, tan en el mapa com en el quadre del mÃ²dul, els diferents resultats.
        '''
        global cur
        global conn
        global itemSel
        global nomBD1
        global contra1
        global host1
        global port1
        global usuari1
        
        global lbl_Cost
        global Fitxer
        
        self.dlg.setEnabled(False)
        Fitxer=datetime.datetime.now().strftime("%Y%m%d%H%M%S%f")
        
        
        self.dlg.taulaResultat.clear()
        self.eliminaTaula()
        self.dlg.lbl_numpol.setText('')
        QApplication.processEvents()
        Fitxer=datetime.datetime.now().strftime("%Y%m%d%H%M%S%f")
        
        
            

        
        '''Control d'errors'''
        llistaErrors = self.controlErrorsInput()
        if len(llistaErrors) > 0:
            llista = "Llista d'errors:\n\n"
            for i in range (0,len(llistaErrors)):
                llista += ("- "+llistaErrors[i] + '\n')
            QMessageBox.information(None, "Error", llista)
            self.dlg.setEnabled(True)
            return
        
        if self.dlg.tabWidget_Destino.currentIndex() != 0:
            if (not(self.on_Change_ComboLeyenda())):
                self.dlg.setEnabled(True)
                return
         
        self.barraEstat_processant()
            
        uri = QgsDataSourceUri()
        try:
            uri.setConnection(host1,port1,nomBD1,usuari1,contra1)
        except Exception as ex:
            print ("Error a la connexio")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            QMessageBox.information(None, "Error", "Error a la connexio")
            conn.rollback()
            self.dlg.setEnabled(True)
            return
            
        #********************************************************************************************************
        #    Afegir l'exportaciÃ³ del layer, i posteriorment llenÃ§ar un avis en cas de que l'entitat sigui buida 
        #********************************************************************************************************
        '''Exportar temporalment la entitat seleccionada de la llegenda a la BBDD'''
        if self.dlg.tabWidget_Destino.currentIndex() != 0: 
            layers = QgsProject.instance().mapLayers().values()
            if layers != None:
                for layer in layers:
                    if layer.name() == self.dlg.comboLeyenda.currentText():
                        try:
                            sql_SRID="SELECT Find_SRID('public', 'ILLES', 'geom')"
                            cur.execute(sql_SRID)
                        except Exception as ex:
                            self.dlg.setEnabled(True)
                            print ("ERROR SELECT SRID ILLES")
                            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
                            message = template.format(type(ex).__name__, ex.args)
                            print (message)
                            QMessageBox.information(None, "Error", "ERROR SELECT SRID ILLES")
                            conn.rollback()
                            self.eliminaTaulesCalcul(Fitxer)
                
                            self.bar.clearWidgets()
                            self.dlg.Progres.setValue(0)
                            self.dlg.Progres.setVisible(False)
                            self.dlg.lblEstatConn.setText('Connectat')
                            self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
                            return
                        auxlist = cur.fetchall()
                        Valor_SRID=auxlist[0][0]
                        layer = self.comprobarValidez(layer,Valor_SRID)
                        error = QgsVectorLayerExporter.exportLayer(layer, 'table="public"."LayerExportat'+Fitxer+'" (geom) '+uri.connectionInfo(), "postgres", layer.crs(), False)
                        if error[0] != 0:
                            iface.messageBar().pushMessage(u'Error', error[1])
                        
                        #cada usuari tindrÃ  la seva taula local temporal "LayerExportat", es una versiÃ³ Local Temp del Layer exportat de la leyenda.
                        #Amb l'objectiu de que dos usuaris puguin treballar amb el mateix nom de la taula, eliminant concurrencia.
                        try:
                            sql_SRID="SELECT Find_SRID('public', 'LayerExportat"+Fitxer+"', 'geom')"
                            cur.execute(sql_SRID)
                        except Exception as ex:
                            print ("ERROR SELECT SRID")
                            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
                            message = template.format(type(ex).__name__, ex.args)
                            print (message)
                            QMessageBox.information(None, "Error", "ERROR SELECT SRID")
                            conn.rollback()
                            self.eliminaTaulesCalcul(Fitxer)
                
                            self.bar.clearWidgets()
                            self.dlg.Progres.setValue(0)
                            self.dlg.Progres.setVisible(False)
                            self.dlg.lblEstatConn.setText('Connectat')
                            self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
                            self.dlg.setEnabled(True)
                            return
                        auxlist = cur.fetchall()
                        Valor_SRID=auxlist[0][0]
                        alter = 'ALTER TABLE "LayerExportat'+Fitxer+'" ALTER COLUMN geom TYPE geometry(Point,'+str(Valor_SRID)+') USING ST_GeometryN(geom,1);'
                        
                        try:
                            cur.execute(alter)
                            conn.commit()
                        except Exception as ex:
                            print ("ALTER TABLE ERROR_geometry")
                            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
                            message = template.format(type(ex).__name__, ex.args)
                            print (message)
                            QMessageBox.information(None, "Error", "ALTER TABLE ERROR_geometry")
                            conn.rollback()
                            self.eliminaTaulesCalcul(Fitxer)
                
                            self.bar.clearWidgets()
                            self.dlg.Progres.setValue(0)
                            self.dlg.Progres.setVisible(False)
                            self.dlg.lblEstatConn.setText('Connectat')
                            self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
                            self.dlg.setEnabled(True)
                            return
                            
                            
                            
                        select = 'select count (*) from "LayerExportat'+Fitxer+'"'
                        
                        try:                
                            cur.execute(select)
                            auxlist = cur.fetchall()
                            if auxlist[0][0] == 0:
                                ErrorMessage = 'La entitat escollida es buida'
                                QMessageBox.information(None, "Error", ErrorMessage+'\n')
                                conn.rollback()
                                self.eliminaTaulesCalcul(Fitxer)
                    
                                self.bar.clearWidgets()
                                self.dlg.Progres.setValue(0)
                                self.dlg.Progres.setVisible(False)
                                self.dlg.lblEstatConn.setText('Connectat')
                                self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
                                return
                                
                        except Exception as ex:
                            print("ERROR select LayerExportat")
                            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
                            Errormessage = template.format(type(ex).__name__, ex.args)
                            print (message)
                            QMessageBox.information(None, "Error", ErrorMessage)
                            conn.rollback()
                            self.eliminaTaulesCalcul(Fitxer)
                
                            self.bar.clearWidgets()
                            self.dlg.Progres.setValue(0)
                            self.dlg.Progres.setVisible(False)
                            self.dlg.lblEstatConn.setText('Connectat')
                            self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
                            self.dlg.setEnabled(True)
                            return
            
        
        '''
        #==============================================
        #    1. Es crea una cÃ²pia de la Xarxa de segments i se'n modifiquen el cost i reverse_cost
        #     on s'hi posa el la llargada del segment.
        # ==============================================
        '''     
           
        sql_xarxa = 'drop table IF EXISTS "Xarxa_Prova";\n'
        sql_xarxa += 'create local temp table "Xarxa_Prova" as  (select * from "'+self.dlg.comboGraf.currentText()+'");\n'
        if self.dlg.comboCost.currentText() == 'Distancia':
            sql_xarxa += 'update "Xarxa_Prova" set "cost"="length", "reverse_cost"="length";'
        else:
            sql_xarxa += 'update "Xarxa_Prova" set "cost"=("length")/("speed"), "reverse_cost"=("length")/("reverse_speed");'
            if (self.dlg.chk_CostNusos.isChecked()):
                """Es suma al camp 'cost' i a 'reverse_cost' el valor dels semafors sempre i quan estigui la opciÃ³ marcada"""
                sql_xarxa +='UPDATE "Xarxa_Prova" set "cost"="cost"+(\"total_cost_semaphore\"), \"reverse_cost\"=\"reverse_cost\"+(\"total_cost_semaphore\");\n'
        
        try:
            cur.execute(sql_xarxa)
            conn.commit()
        except Exception as ex:
            print ("CREATE Xarxa_Prova TABLE ERROR")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            QMessageBox.information(None, "Error", "CREATE Xarxa_Prova TABLE ERROR")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.dlg.setEnabled(True)
            return
        
        '''
        #==============================================
        #    2. Es genera un codi 'Carrer_Num_Bis' amb les dades que l'usuari ha introduit i es passa a una funciÃ³ auxiliar on
        #    es comprova que aquest existeixi. En el cas que sÃ­ que existeixi, aleshores nomÃ©s retorna el codi. Altrament, es busca 
        #    el mÃ©s proper. I en el cas que no n'existeixi cap, s'envia un missatge d'error
        # ==============================================
        '''
        while len(itemSel) < 5:
            itemSel = '0' + itemSel
        numero = self.dlg.txt_Numero.text()
        if int(float(numero)) < 10:
            numero = '00' + numero
        elif int(float(numero)) < 100:
            numero = '0' + numero
        lletra = self.dlg.comboLletra.currentText()
        if lletra == ' ':
            lletra = 'x'
        CNB = itemSel + numero + lletra       
        try:
            CNB = self.comprovaCNB(CNB,itemSel,numero,lletra)
        except Exception as ex:
            print ("Error comprovaCNB")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            QMessageBox.information(None, "Error", "Error comprovaCNB")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.dlg.setEnabled(True)
            return
        if CNB == '-1':
            QMessageBox.information(None, "Error", "TRAM DE VIA SENSE CAP NUMERO POSTAL:\n" + self.dlg.txt_nomCarrer.text() + " " + self.dlg.txt_Numero.text() + " " + self.dlg.comboLletra.currentText())
            self.barraEstat_connectat()
            
            drop = 'drop table IF EXISTS "Xarxa_Prova";\n'
           
            try:
                cur.execute(drop)
                conn.commit()
            except Exception as ex:
                print ("Error DROP break adreÃ§a no trobada")
                template = "An exception of type {0} occurred. Arguments:\n{1!r}"
                message = template.format(type(ex).__name__, ex.args)
                print (message)
                QMessageBox.information(None, "Error", "Error DROP break adreÃ§a no trobada")
                conn.rollback()
                self.eliminaTaulesCalcul(Fitxer)
                self.dlg.setEnabled(True)
                return
            self.dlg.setEnabled(True)
            return
        
        '''
        #==============================================
        #    3. Mostra l'adreÃ§a sobre la qual es fa la cerca a la interficie del modul
        # ==============================================
        '''
        self.dlg.lbl_numpol.setText(self.dlg.txt_nomCarrer.text() + " " + CNB[5:8] + " "+ CNB[-1])
        a=time.time()
        
        if(self.dlg.chk_Local.isChecked()):
            self.local(CNB,uri)     
        
        else:
            self.server(CNB)
        '''
        #    15. Es posa la barra informativa inferior a connectat
        '''
        self.dlg.setEnabled(True)
        self.barraEstat_connectat()
        print ("Durada: "+str(int(time.time()-a))+" s.")
        
    def local(self,CNB, uri):
        global Fitxer
        global TEMPORARY_PATH
        QApplication.processEvents()
        if self.dlg.tabWidget_Destino.currentIndex() == 0:
            sql_punts = 'SELECT * FROM \"' + self.dlg.comboCapaDesti.currentText() + '\"'
        else:
            sql_punts = "SELECT * FROM \"LayerExportat"+Fitxer+"\""
        
        QApplication.processEvents()
        uri.setDataSource("","("+sql_punts+")","geom","","id")
        QApplication.processEvents()
        end_lyr = QgsVectorLayer(uri.uri(False), "fin", "postgres")
        QApplication.processEvents()
        
        sql_punt = 'SELECT * FROM  "address" WHERE "designator" = \'' + CNB + '\'' 
        QApplication.processEvents()
        uri.setDataSource("","("+sql_punt+")","geom","","id_address")
        QApplication.processEvents()
        start_lyr = QgsVectorLayer(uri.uri(False), "inici", "postgres")
        QApplication.processEvents()
        
        
        '''
        #  S'afegeix el punt d'origen a pantalla
        
        # Es prepara el titol de la capa que apareixerÃ  a la llegenda
        '''
        titol=self.dlg.lbl_numpol.text()
        titol2='Entitat d\'origen: '
        titol3=titol2.encode('utf8','strict')+titol.encode('utf8','strict')
        vlayer = start_lyr
        QApplication.processEvents()
        
        if vlayer.isValid():
            crs = vlayer.dataProvider().sourceCrs()
            vlayer_temp = QgsVectorLayer("Point", titol3.decode('utf8'), "memory")
            vlayer_temp.setCrs(crs)
            vlayer_temp.dataProvider().addAttributes(vlayer.fields())
            vlayer_temp.updateFields()
            vlayer_temp.dataProvider().addFeatures(vlayer.getFeatures())
            symbols = vlayer_temp.renderer().symbols(QgsRenderContext())
            symbol=symbols[0]
            '''S'afegeix el color a la nova entitat'''
            symbol.setColor(QColor.fromRgb(50,250,250))
            QgsProject.instance().addMapLayer(vlayer_temp,False)
            root = QgsProject.instance().layerTreeRoot()
            myLayerNode=QgsLayerTreeLayer(vlayer_temp)
            root.insertChildNode(0,myLayerNode)
            myLayerNode.setCustomProperty("showFeatureCount", False)
            QApplication.processEvents()
            ''''S'afegeix la capa a la pantalla'''
            iface.mapCanvas().refresh()
            #qgis.utils.iface.legendInterface().refreshLayerSymbology(vlayer)
        else:
            QMessageBox.information(None, "LAYER ERROR 3:", "%s\n\nThe layer %s is not valid" % ("error","nom_layer"))
            
            
            
        '''CÃ¡lculo de los caminos mÃ¡s cortos'''
        
        
        try:
            #sql_inici = 'SELECT "UTM_x","UTM_y" FROM  "address" WHERE "designator" = \'' + CNB + '\'' 
            sql_inici = 'SELECT ST_X(geom), ST_Y(geom) FROM  "address" WHERE "designator" = \'' + CNB + '\'' 
            # ST_X(geom), ST_Y(geom)
            
            cur.execute(sql_inici)
            coordenadas = cur.fetchall()
            start_point = ((str(coordenadas[0]))[1:-1])
        except Exception as ex:
            print ("Error SELECT coordenades")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            QMessageBox.information(None, "Error", "Error SELECT coordenades")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.dlg.setEnabled(True)
            return
        
        sql_xarxa="SELECT * FROM \""+self.dlg.comboGraf.currentText()+"\""
        QApplication.processEvents()
        uri.setDataSource("","("+sql_xarxa+")","geom","","id")
        QApplication.processEvents()
        network_lyr = QgsVectorLayer(uri.uri(False), "xarxa", "postgres")
        QApplication.processEvents()
        
        resultado = self.calculo_Local(network_lyr,CNB,uri,start_point,end_lyr)

        
        '''Borrar tramos sobrantes'''
        
        features = resultado['OUTPUT'].getFeatures(QgsFeatureRequest().addOrderBy('cost',True))
        try:
            limit = self.getLimit()
        except Exception as ex:
            print ("Error getLimit")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            QMessageBox.information(None, "Error", "Error getLimit")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.dlg.setEnabled(True)
            return
        
        resultado['OUTPUT'].startEditing()
        fields = resultado['OUTPUT'].fields()
        for x in range(len(fields)):
            if('name' in fields[x].displayName().lower()):
                resultado['OUTPUT'].renameAttribute(x,'NomEntitat')
            elif(fields[x].displayName()=='id'):
                resultado['OUTPUT'].renameAttribute(x,'entitatid')
            elif(fields[x].displayName()=='cost'):
                resultado['OUTPUT'].renameAttribute(x,'agg_cost') 
        resultado['OUTPUT'].addAttribute(QgsField('ordre', QVariant.Int))
        
        resultado['OUTPUT'].commitChanges()
        
        
        resultado['OUTPUT'].startEditing()
        featureOrdreList = [] #Variable usada para despuÃ©s poder nombrar fÃ¡cilmente las etiquetas
        x=0
        for feature in features:
            if(x>=limit):
                resultado['OUTPUT'].deleteFeature(feature.id())
            else:
                self.getIndexOrdre(resultado['OUTPUT'])
                resultado['OUTPUT'].changeAttributeValue(feature.id(),self.getIndexOrdre(resultado['OUTPUT']),x+1)
                featureOrdreList.append(feature.id())
            x = x+1
        resultado['OUTPUT'].commitChanges()
        
  
  
        '''Borrar puntos sobrantes'''
        
        puntos_destino = self.save_vlayer(end_lyr) 
        puntos_destino['OUTPUT'].startEditing()
        fields = puntos_destino['OUTPUT'].fields()
        for x in range(len(fields)):
            if('name' in fields[x].displayName().lower()):
                puntos_destino['OUTPUT'].renameAttribute(x,'NomEntitat')
            elif(fields[x].displayName()=='id'):
                puntos_destino['OUTPUT'].renameAttribute(x,'entitatid')
                            
        puntos_destino['OUTPUT'].addAttribute(QgsField('ordre', QVariant.Int))
        puntos_destino['OUTPUT'].commitChanges()
        
                     
        
        features = puntos_destino['OUTPUT'].getFeatures()
        puntos_destino['OUTPUT'].startEditing()
        for feature in features: 
            if(self.featureNotInResult(feature,resultado['OUTPUT'])):
                puntos_destino['OUTPUT'].deleteFeature(feature.id())
            else:
                puntos_destino['OUTPUT'].changeAttributeValue(feature.id(),self.getIndexOrdre(puntos_destino['OUTPUT']),self.compareToGetOrdre(feature,resultado['OUTPUT']))
        puntos_destino['OUTPUT'].commitChanges()
        
        
        '''Borrar atributos sobrantes del resultado'''
        
        resultado['OUTPUT'].startEditing()
        indexAttributesToDelete = []
        for x in range(len(resultado['OUTPUT'].attributeList())):
            if(resultado['OUTPUT'].attributeDisplayName(x)!='ordre' and resultado['OUTPUT'].attributeDisplayName(x)!='entitatid' and resultado['OUTPUT'].attributeDisplayName(x)!='NomEntitat' and resultado['OUTPUT'].attributeDisplayName(x)!='agg_cost'):
                indexAttributesToDelete.append(x)
        resultado['OUTPUT'].deleteAttributes(indexAttributesToDelete)
        resultado['OUTPUT'].commitChanges()
        

        
        '''Borrar atributos sobrantes de los destinos'''
        
        puntos_destino['OUTPUT'].startEditing()
        indexAttributesToDelete.clear()
        for x in range(len(puntos_destino['OUTPUT'].attributeList())):
            if(puntos_destino['OUTPUT'].attributeDisplayName(x)!='ordre' and puntos_destino['OUTPUT'].attributeDisplayName(x)!='entitatid' and puntos_destino['OUTPUT'].attributeDisplayName(x)!='NomEntitat'):
                indexAttributesToDelete.append(x)
        puntos_destino['OUTPUT'].deleteAttributes(indexAttributesToDelete)
        puntos_destino['OUTPUT'].commitChanges()
        
        
        '''RepresentaciÃ³n en taulaResultat'''
        
        rowCount = self.dlg.taulaResultat.rowCount()
        self.dlg.taulaResultat.setColumnCount(2)
        self.dlg.taulaResultat.setHorizontalHeaderLabels(['Entitat', lbl_Cost])
        for x in range (rowCount,limit):
            self.dlg.taulaResultat.insertRow(x)
            feature = resultado['OUTPUT'].getFeature(featureOrdreList[x])
            self.dlg.taulaResultat.setItem(x, 0, QTableWidgetItem(str(feature['NomEntitat'])))
            if self.dlg.comboCost.currentText() == 'Distancia':
                self.dlg.taulaResultat.setItem(x, 1, QTableWidgetItem(str(round(feature['agg_cost']))))
            else:
                self.dlg.taulaResultat.setItem(x, 1, QTableWidgetItem(str(round((feature['agg_cost']),1))))

        
      
        '''RepresentaciÃ³n caminos de destino'''
        
        if self.dlg.tabWidget_Destino.currentIndex() == 0:
            titol=self.dlg.comboCapaDesti.currentText()
        else:
            titol=self.dlg.comboLeyenda.currentText()

        titol2='Camins mÃ©s propers a '
        titol3=titol2.encode('utf8','strict')+titol.encode('utf8','strict')
        vlayer = resultado['OUTPUT']
        vlayer.setName(titol3.decode('utf8'))
        QApplication.processEvents()
        
        if(vlayer.isValid):
            symbols = vlayer.renderer().symbols(QgsRenderContext())
            symbol=symbols[0]
            
            '''Es prepara cada camÃ­ de la capa amb diferent color i gruix en funcio de la distÃ ncia a la que estigui de l'origen '''
            GradSymMin = 0
            GradSymMax = limit
            GradSymNoOfClasses = limit
            #GradSymInterval = round(((int(GradSymMax) - int(GradSymMin)) / float(GradSymNoOfClasses)),0)
            GradSymInterval = 1.0
            myRangeList = []
            gruix = 2.5
            interval = float(gruix/limit)
            
            
            for x in range (GradSymNoOfClasses):
                if x == 0:
                    min = 0
                    max = 1
                    color = QColor(0, 255, 255*x/GradSymNoOfClasses)
                elif x == (GradSymNoOfClasses - 1):
                    min = GradSymMax-1
                    max = GradSymMax
                    color =  QColor(255*x/GradSymNoOfClasses, 0, 0)
                else:
                    min = int(GradSymMin)+(GradSymInterval*x)+0.001
                    max = int(GradSymMin)+GradSymInterval*(x+1)
                    color = QColor(255*x/GradSymNoOfClasses, 255-(255*x/GradSymNoOfClasses), 0)
                
                feature = resultado['OUTPUT'].getFeature(featureOrdreList[x])
                label = str(feature['ordre']) + ". " +str(feature['NomEntitat'])
                symbol=QgsLineSymbol()

                registry = QgsSymbolLayerRegistry()
                lineMeta = registry.symbolLayerMetadata("SimpleLine")
                #Line layer
                lineLayer = lineMeta.createSymbolLayer({'width': '1', 'color': '255,0,0', 'offset': '0', 'penstyle': 'solid', 'use_custom_dash': '0', 'joinstyle': 'bevel', 'capstyle': 'round'})

                symbol.deleteSymbolLayer(0)
                symbol.appendSymbolLayer(lineLayer)

                symbol.setWidth(gruix)
                symbol.setColor(color)                          
                
                ranger = QgsRendererRange(min, max, symbol, label)
                myRangeList.append(ranger)
                gruix -= float(interval)

            '''Es renderitzen els estils de cada cami'''
            fieldname='ordre'
            format = QgsRendererRangeLabelFormat()
            
            '''S'apliquen els estils a la capa'''
            renderer = QgsGraduatedSymbolRenderer(fieldname,myRangeList)           
            renderer.setLabelFormat(format,False) #Si en algÃºn momento hay problema con el texto de los sÃ­mbolos mostrados en leyenda, podrÃ­a estar relacionado con este booleano

            
            renderer.setOrderByEnabled(True)
            listOrder = []
            listOrder.append(QgsFeatureRequest().OrderByClause("ordre",True))
            renderer.setOrderBy(QgsFeatureRequest().OrderBy(listOrder))
            
        
            vlayer.setRenderer(renderer)
            QApplication.processEvents()
            
            
            QgsProject.instance().addMapLayer(vlayer,False)
            root = QgsProject.instance().layerTreeRoot()
            myLayerNode=QgsLayerTreeLayer(vlayer)
            root.insertChildNode(0,myLayerNode)
            myLayerNode.setCustomProperty("showFeatureCount", False)
            QApplication.processEvents()
            iface.mapCanvas().refresh()
            self.eliminaTaulesCalcul(Fitxer)
            ''''S'afegeix la capa a la pantalla'''
            #iface.legendInterface().refreshLayerSymbology(vlayer)
        else:
            QMessageBox.information(None, "LAYER ERROR 1:", "%s\n\nThe layer %s is not valid" % ("error","nom_layer"))
    
        '''
         # S'afegeixen els punts de destÃ­ a pantalla amb les corresponents etiquetes amb els seus noms
        
        # Es prepara el titol de la capa que apareixerÃ  a la llegenda
        '''
        if self.dlg.tabWidget_Destino.currentIndex() == 0:
            titol=self.dlg.comboCapaDesti.currentText()
        else:
            titol=self.dlg.comboLeyenda.currentText() 
                   
        titol2='Entitats de destÃ­ '
        titol3=titol2.encode('utf8','strict')+titol.encode('utf8','strict')
        vlayer = puntos_destino['OUTPUT']
        QApplication.processEvents()

        if vlayer.isValid():
            symbols = vlayer.renderer().symbols(QgsRenderContext())
            symbol=symbols[0]
            symbol.setColor(QColor.fromRgb(250,50,250))
            '''S'afegeixen totes les propietats a la capa: color, tipus de font de l'etiqueta, colocacio, nom del camp a mostrar, etc'''

            layer_settings  = QgsPalLayerSettings()
            text_format = QgsTextFormat()
            
            text_format.setFont(QFont("Arial", 16))
            text_format.setSize(16)
            vlayer.setName(titol3.decode('utf8'))
            
            buffer_settings = QgsTextBufferSettings()
            buffer_settings.setEnabled(True)
            buffer_settings.setSize(1)
            buffer_settings.setColor(QColor("white"))
            
            text_format.setBuffer(buffer_settings)
            layer_settings.setFormat(text_format)
            
            layer_settings.isExpression = True
            layer_settings.fieldName = "concat( ordre,'. ',NomEntitat)"
            layer_settings.placement = QgsPalLayerSettings.AroundPoint # Poso AroundPoint privisonalment perque sÃ© que funciona, abans hi havia escrit un 2
            layer_settings.scaleVisibility = True
            layer_settings.minimumScale = 20000
            layer_settings.maximumScale = 3000
            
            layer_settings.enabled = True
            
            layer_settings = QgsVectorLayerSimpleLabeling(layer_settings)
            vlayer.setLabelsEnabled(True)
            vlayer.setLabeling(layer_settings)
            vlayer.triggerRepaint()
            QApplication.processEvents()
            QgsProject.instance().addMapLayer(vlayer,False)
            root = QgsProject.instance().layerTreeRoot()
            myLayerNode=QgsLayerTreeLayer(vlayer)
            root.insertChildNode(0,myLayerNode)
            myLayerNode.setCustomProperty("showFeatureCount", False)
            QApplication.processEvents()
            ''''S'afegeix la capa a la pantalla'''
            iface.mapCanvas().refresh()
            #qgis.utils.iface.legendInterface().refreshLayerSymbology(vlayer)
        else:
            QMessageBox.information(None, "LAYER ERROR 2:", "%s\n\nThe layer %s is not valid" % ("error","nom_layer"))
            
        
                   
                   
                    
    def server(self, CNB):
        global Fitxer
        
        '''CÃ¡lculo en el servidor'''
        '''
        #==============================================
        #    4. S'ajunten tots els punts tan de sortida com de destÃ­ en una sola taula per preparar-los per la
        #    funciÃ³ del PGRounting pgr_withPointsKSP: dintreilla + punts de la capa de destÃ­
        #    4.1 S'esborra i es crea una nova taula
        # ==============================================
        '''
        drop = 'DROP TABLE IF EXISTS NecessaryPoints_'+Fitxer+';'
        try:
            cur.execute(drop)
            conn.commit()
        except Exception as ex:
            print ("Error DROP TABLE 1")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            QMessageBox.information(None, "Error", "Error DROP TABLE 1")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.dlg.setEnabled(True)
            return
        
        create = 'CREATE TABLE NecessaryPoints_'+Fitxer+' (\n'
        create += "\tpid    serial primary key,\n"
        create += "\tgeom geometry,\n"
        create += "\tentitatID int8,\n"
        create += "\tedge_id BIGINT,\n"
        create += "\tfraction FLOAT,\n"
        create += "\tnewPoint geometry);"
        try:
            cur.execute(create)
            conn.commit()
        except Exception as ex:
            print ("Error CREATE NecessaryPoints")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            QMessageBox.information(None, "Error", "Error CREATE NecessaryPoints")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.dlg.setEnabled(True)
            return
            
        '''
        #    4.2 S'afegeixen els punts necessaris a la taula
        '''            
        insert = 'INSERT INTO NecessaryPoints_'+Fitxer+' (entitatID,geom) (SELECT 0, ST_Centroid("geom") geom from "address" where "designator" = \''+CNB+'\');\n'
        if self.dlg.tabWidget_Destino.currentIndex() == 0:
            insert += 'INSERT INTO NecessaryPoints_'+Fitxer+' (entitatID, geom) (SELECT "id", ST_Centroid("geom") geom from "' + self.dlg.comboCapaDesti.currentText() + '" order by "id");'
        else:
            insert += 'INSERT INTO NecessaryPoints_'+Fitxer+' (entitatID, geom) (SELECT "id", ST_Centroid("geom") geom from "LayerExportat'+Fitxer+'" order by "id");'
        
        try:
            cur.execute(insert)
            conn.commit()
        except Exception as ex:
            print ("Error INSERT NecessaryPoints")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            QMessageBox.information(None, "Error", "Error INSERT NecessaryPoints")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.dlg.setEnabled(True)
            return
        
        '''
        #    4.3 S'afegeix el id del tram al que estan mÃ©s prÃ²xims els punts, els punts projectats sobre el graf 
        #    i la fracciÃ³ de segment a on estant 
        '''
       
        try:
            sql_SRID="SELECT Find_SRID('public', '"+self.dlg.comboGraf.currentText()+"', 'geom')"
            cur.execute(sql_SRID)
        except Exception as ex:
            print ("ERROR SELECT SRID")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            QMessageBox.information(None, "Error", "ERROR SELECT SRID")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)

            self.bar.clearWidgets()
            self.dlg.Progres.setValue(0)
            self.dlg.Progres.setVisible(False)
            self.dlg.lblEstatConn.setText('Connectat')
            self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
            self.dlg.setEnabled(True)
            return
        auxlist = cur.fetchall()
        Valor_SRID=auxlist[0][0]
       
        update = 'UPDATE NecessaryPoints_'+Fitxer+' SET geom = ST_Transform(geom,'+str(Valor_SRID)+');\n'
        update += 'UPDATE NecessaryPoints_'+Fitxer+' set "edge_id"=tram_proper."tram_id" from (SELECT distinct on(Poi."pid") Poi."pid" As Punt_id,Sg."id" as Tram_id, ST_Distance(Sg."geom",Poi."geom")  as dist FROM "Xarxa_Prova" as Sg,NecessaryPoints_'+Fitxer+' AS Poi ORDER BY  Poi."pid",ST_Distance(Sg."geom",Poi."geom"),Sg."id") tram_proper where NecessaryPoints_'+Fitxer+'."pid"=tram_proper."punt_id";\n'
        update += 'UPDATE NecessaryPoints_'+Fitxer+' SET fraction = ST_LineLocatePoint(e.geom, NecessaryPoints_'+Fitxer+'.geom),newPoint = ST_LineInterpolatePoint(e."geom", ST_LineLocatePoint(e."geom", NecessaryPoints_'+Fitxer+'."geom")) FROM "Xarxa_Prova" AS e WHERE NecessaryPoints_'+Fitxer+'."edge_id" = e."id";\n'
        try:
            cur.execute(update)
            conn.commit()
        except Exception as ex:
            print ("Error UPDATE NecessaryPoints")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            QMessageBox.information(None, "Error", "Error UPDATE NecessaryPoints")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.dlg.setEnabled(True)
            return
            
        '''
        #    4.4 Es fa una consulta per poder generar una sentencia SQL que faci la cerca de
        #    tots els camins mÃ©s curts a tots el punts necessaris
        '''
        select = 'select * from NecessaryPoints_'+Fitxer+' order by pid'
        try:
            cur.execute(select)
            vec = cur.fetchall()
        except Exception as ex:
            print ("Error SELECT NecessaryPoints")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            QMessageBox.information(None, "Error", "Error SELECT NecesaryPoints")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.dlg.setEnabled(True)
            return 
        #create = 'create local temp table "Resultat" as SELECT * FROM (\n'
        create = 'create table "Resultat" as SELECT * FROM (\n'
        for x in range (0,len(vec)):
            if x < len(vec) and x >= 2:
                create += 'UNION\n'
            if x != 0:
                if vec[x][4] == 1.0 or vec[x][4] == 0.0:
                    create += 'select '+ str(x) +' as routeID,'+ str(vec[x][2]) +' as entitatID, * from pgr_withPointsKSP(\'SELECT id, source, target, cost, reverse_cost FROM "Xarxa_Prova" ORDER BY id\',\'SELECT pid, edge_id, fraction from NecessaryPoints_'+Fitxer+'\',-1,' + str(vec[x][2])+',1)\n'
                else:
                    create += 'select '+ str(x) +' as routeID,'+ str(vec[x][2]) +' as entitatID, * from pgr_withPointsKSP(\'SELECT id, source, target, cost, reverse_cost FROM "Xarxa_Prova" ORDER BY id\',\'SELECT pid, edge_id, fraction from NecessaryPoints_'+Fitxer+'\',-1,-' + str(vec[x][0]) +',1)\n'
        create += ')QW ORDER BY routeID, seq;'
        
        '''
        #    4.5 SelecciÃ³ del nom del camp on figura el Nom de l'entitat de destÃ­
        '''
        try:
            if self.dlg.tabWidget_Destino.currentIndex() == 0:
                select="SELECT column_name FROM information_schema.columns WHERE table_schema = 'public' and table_name = '"+ self.dlg.comboCapaDesti.currentText() +"'and column_name like 'name';"
            else:
                select="SELECT column_name FROM information_schema.columns WHERE table_schema = 'public' and table_name = 'LayerExportat"+Fitxer+"'and lower(column_name) like 'name';"
            cur.execute(select)
            nomCamp = cur.fetchall()
        except Exception as ex:
            print ("Error SELECT CAMP NOM")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            QMessageBox.information(None, "Error", "Error SELECT CAMP NOM")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.dlg.setEnabled(True)
            return
            
        '''
        #    5. DestrucciÃ³ i creaciÃ³ de la taula on figuren tots els camins possibles
        '''
        drop = 'DROP TABLE IF EXISTS "Resultat";'
        try:
            cur.execute(drop)
            conn.commit()
        except Exception as ex:
            print ("Error DROP TABLE 2")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            QMessageBox.information(None, "Error", "Error DROP TABLE 2")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.dlg.setEnabled(True)
            return
        
        try:
            cur.execute(create)
            conn.commit()
        except Exception as ex:
            print ("Error CREATE Resultat")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            QMessageBox.information(None, "Error", "Error CREATE Resultat")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.dlg.setEnabled(True)
            return
        
        '''
        #    6. DestrucciÃ³ i creaciÃ³ de la taula "Segments finals" on figuren tots els camins possibles que sÃ³n prinicipi i/o final
        '''

        drop = "DROP TABLE IF EXISTS \"SegmentsFinals\";"
        try:
            cur.execute(drop)
            conn.commit()
        except Exception as ex:
                print ("Error DROP Table 1")
                template = "An exception of type {0} occurred. Arguments:\n{1!r}"
                message = template.format(type(ex).__name__, ex.args)
                print (message)
                QMessageBox.information(None, "Error", "Error DROP Table 1")
                conn.rollback()
                self.eliminaTaulesCalcul(Fitxer)
                self.dlg.setEnabled(True)
                return
        
        create = "CREATE local temp TABLE \"SegmentsFinals\" (\n"
        create += "\trouteid int8,\n"
        create += "\tedge int8,\n"
        create += "\t\"edgeAnt\" int8,\n"
        create += "\tfraction FLOAT,\n"
        create += "\t\"ordreTram\" int8,\n"
        create += "\t\"cutEdge\" geometry);"
        try:
            cur.execute(create)
            conn.commit()
        except Exception as ex:
            print ("Error CREATE SegmentsFinals")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            QMessageBox.information(None, "Error", "Error CREATE SegmentsFinals")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.dlg.setEnabled(True)
            return
            
        '''
        #    6.1 Query per seleccionar els segments que sÃ³n inici i final
        '''
        select = 'select routeid, node, edge from "Resultat" order by routeid, path_seq;'
        try:
            cur.execute(select)
            vec = cur.fetchall()
            conn.commit()            
        except Exception as ex:
            print ("Error CREATE Resultat")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            QMessageBox.information(None, "Error", "Error CREATE Resultat")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.dlg.setEnabled(True)
            return
            
        insert = ''
        for x in range (len(vec)):
            if vec[x][1] < 0:
                if vec[x][1] != -1:
                    insert += 'INSERT INTO "SegmentsFinals" (routeid, edge, "edgeAnt", "ordreTram") VALUES (' + str(vec[x][0]) + ', ' + str(vec[x-1][2]) + ', ' + str(vec[x-2][2]) + ', ' + str(2) +');\n'
                else:
                    insert += 'INSERT INTO "SegmentsFinals" (routeid, edge, "edgeAnt", "ordreTram") VALUES (' + str(vec[x][0]) + ', ' + str(vec[x][2]) + ', ' + str(vec[x+1][2]) + ', ' + str(1) + ');\n'
        try:
            cur.execute(insert)
            conn.commit()            
        except Exception as ex:
            print ("Error INSERT SegmentsFinals")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            QMessageBox.information(None, "Error", "Error INSERT SegmentsFinals")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.dlg.setEnabled(True)
            return
            
        '''
        #    6.2 UPDATE per poder afegir la fracciÃ³ en quÃ¨ es troba el punt sobre el segment
        '''
        select = 'select routeid, edge, "ordreTram" from "SegmentsFinals" order by routeid, "ordreTram";'
        try:
            cur.execute(select)
            vec = cur.fetchall()
            conn.commit()
        except Exception as ex:
            print ("Error SELECT SegmentsFinals")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            QMessageBox.information(None, "Error", "Error SELECT SegmentsFinals")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.dlg.setEnabled(True)
            return

        update = ''
        for x in range(len(vec)):
            ruta = vec[x][0]
            edge = vec[x][1]
            ordre = vec[x][2]
            if ordre == 1:
                update += 'update "SegmentsFinals" s set fraction = n.fraction from NecessaryPoints_'+Fitxer+' n where n.edge_id = '+str(edge)+' and s.edge ='+str(edge)+' and s."ordreTram" = 1 and s.routeid = '+str(ruta)+' and n.entitatid = 0;\n'
            else:
                update += 'update "SegmentsFinals" s set fraction = n.fraction from NecessaryPoints_'+Fitxer+' n where n.edge_id = '+str(edge)+' and s.edge ='+str(edge)+' and s."ordreTram" = 2 and s.routeid = '+str(ruta)+' and n.pid = '+str(ruta+1)+';\n'

        try:
            cur.execute(update)
            conn.commit()            
        except Exception as ex:
            print ("Error UPDATE SegmentsFinals")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            QMessageBox.information(None, "Error", "Error UPDATE SegmentsFinals")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.dlg.setEnabled(True)
            return
        '''
        #    6.3 Query per escollir i afegir el tros de tram que correspon a cada inici i final 
        #    Posteriorment es fa un UPDATE del camp de geometria de la taula 'SegmentsFinals' amb els trams ja retallats
        '''
        select = 'select * from "SegmentsFinals" order by routeid;'
        try:
            cur.execute(select)
            vec = cur.fetchall()
            conn.commit()
        except Exception as ex:
            print ("Error SELECT SegmentsFinals")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            QMessageBox.information(None, "Error", "Error SELECT SegmentsFinals")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.dlg.setEnabled(True)
            return
        updateSegment = ''
        for x in range(len(vec)):
            ordre = vec[x][4]
            fraction = vec[x][3]
            edgeAnt = vec[x][2]
            edge = vec[x][1]

            sqlVersio = "SELECT extversion FROM pg_extension WHERE extname = 'postgis';"
            cur.execute(sqlVersio)
            versio = cur.fetchall()[0][0]
            if versio[0:2] == '2.':
                selectTouch = 'SELECT ST_Touches((select ST_Line_Substring("Xarxa_Prova"."geom",0,'+str(fraction)+') as geom from "Xarxa_Prova" where "id"='+str(edge)+'),(select geom as  geom from "Xarxa_Prova" where "id"='+str(edgeAnt)+'));'
            if versio[0:2] == '3.':
                selectTouch = 'SELECT ST_Touches((select ST_LineSubstring("Xarxa_Prova"."geom",CAST(0 AS FLOAT8),CAST('+str(fraction)+'AS FLOAT8)) as geom from "Xarxa_Prova" where "id"='+str(edge)+'),(select geom as  geom from "Xarxa_Prova" where "id"='+str(edgeAnt)+'));'
            try:
                cur.execute(selectTouch)
                resposta = cur.fetchall()
                conn.commit()
            except Exception as ex:
                print ("Error SELECT TOUCH")
                template = "An exception of type {0} occurred. Arguments:\n{1!r}"
                message = template.format(type(ex).__name__, ex.args)
                print (message)
                QMessageBox.information(None, "Error", "Error SELECT TOUCH")
                conn.rollback()
                self.eliminaTaulesCalcul(Fitxer)
                self.dlg.setEnabled(True)
                return
            if edgeAnt != -1:  
                if versio[0:2] == '2.': 
                    if resposta[0][0]:
                        updateSegment += 'update "SegmentsFinals" sf set "cutEdge" = ST_Line_Substring(s."geom",0,'+str(fraction)+') from "Xarxa_Prova" s where sf."edge"='+str(edge)+' and s."id"='+str(edge)+' and sf."routeid" = '+str(vec[x][0])+';\n'
                    else:
                        updateSegment += 'update "SegmentsFinals" sf set "cutEdge" = ST_Line_Substring(s."geom",'+str(fraction)+',1) from "Xarxa_Prova" s where sf."edge"='+str(edge)+' and s."id"='+str(edge)+' and sf."routeid" = '+str(vec[x][0])+';\n'
                if versio[0:2] == '3.':
                    if resposta[0][0]:
                        updateSegment += 'update "SegmentsFinals" sf set "cutEdge" = ST_LineSubstring(s."geom",CAST(0 AS FLOAT8),'+str(fraction)+') from "Xarxa_Prova" s where sf."edge"='+str(edge)+' and s."id"='+str(edge)+' and sf."routeid" = '+str(vec[x][0])+';\n'
                    else:
                        updateSegment += 'update "SegmentsFinals" sf set "cutEdge" = ST_LineSubstring(s."geom",'+str(fraction)+',1) from "Xarxa_Prova" s where sf."edge"='+str(edge)+' and s."id"='+str(edge)+' and sf."routeid" = '+str(vec[x][0])+';\n'

            else:
                if ordre == 1:
                    fractForward = vec[x+1][3]
                else:
                    fractForward = vec[x-1][3]

                if versio[0:2] == '2.':
                    if fraction >= fractForward:
                        updateSegment += 'update "SegmentsFinals" sf set "cutEdge" = ST_Line_Substring(s."geom",'+str(fractForward)+','+str(fraction)+') from "Xarxa_Prova" s where sf."ordreTram" = '+ str(ordre)+' and sf."edge"='+str(edge)+' and s."id"='+str(edge)+' and sf."routeid" = '+str(vec[x][0])+';\n'
                    else:
                        updateSegment += 'update "SegmentsFinals" sf set "cutEdge" = ST_Line_Substring(s."geom",'+str(fraction)+','+str(fractForward)+') from "Xarxa_Prova" s where sf."ordreTram" = '+ str(ordre)+' and sf."edge"='+str(edge)+' and s."id"='+str(edge)+' and sf."routeid" = '+str(vec[x][0])+';\n'
                if versio[0:2] == '3.': 
                    if fraction >= fractForward:
                        updateSegment += 'update "SegmentsFinals" sf set "cutEdge" = ST_LineSubstring(s."geom",'+str(fractForward)+','+str(fraction)+') from "Xarxa_Prova" s where sf."ordreTram" = '+ str(ordre)+' and sf."edge"='+str(edge)+' and s."id"='+str(edge)+' and sf."routeid" = '+str(vec[x][0])+';\n'
                    else:
                        updateSegment += 'update "SegmentsFinals" sf set "cutEdge" = ST_LineSubstring(s."geom",'+str(fraction)+','+str(fractForward)+') from "Xarxa_Prova" s where sf."ordreTram" = '+ str(ordre)+' and sf."edge"='+str(edge)+' and s."id"='+str(edge)+' and sf."routeid" = '+str(vec[x][0])+';\n'
                            

        try:
            cur.execute(updateSegment)
            conn.commit()
        except Exception as ex:
            print ("Error UPDATE SegmentsFinals Geometries")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            QMessageBox.information(None, "Error", "Error UPDATE SegmentsFinals Geometries")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.dlg.setEnabled(True)
            return
        
        '''
        #    7. S'afegeix i s'actualitza el camp de geometria a la taula resultat
        '''
        alter = 'ALTER TABLE "Resultat" ADD COLUMN newEdge geometry;\n'
        alter += 'update "Resultat" r set newedge = s.geom from "Xarxa_Prova" s where s.id = r.edge;'

        try:
            cur.execute(alter)
            conn.commit()
        except Exception as ex:
            print ("Error ALTER and UPDATE Resultat Geometries")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            QMessageBox.information(None, "Error", "Error ALTER and UPDATE Resultat Geometries")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.dlg.setEnabled(True)
            return

        '''
        #    8. UPDATE per actualitzar els trams retallats a la taula 'Resultat'
        '''
        update = 'update "Resultat" r set newedge = s."cutEdge" from "SegmentsFinals" s where s."routeid" = r.routeid and s.edge = r.edge;'
        try:
            cur.execute(update)
            conn.commit()
        except Exception as ex:
            print ("Error ALTER and UPDATE Resultat Geometries")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            QMessageBox.information(None, "Error", "Error ALTER and UPDATE Resultat Geometries")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.dlg.setEnabled(True)
            return
        
        uri = QgsDataSourceUri()
        try:
            uri.setConnection(host1,port1,nomBD1,usuari1,contra1)
        except Exception as ex:
            print ("Error a la connexio")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            QMessageBox.information(None, "Error", "Error a la connexio")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.dlg.setEnabled(True)
            return
        '''
        sql_resultat = 'SELECT * FROM  "Resultat";' 
        QApplication.processEvents()
        uri.setDataSource("","("+sql_resultat+")","newedge","","id")
        QApplication.processEvents()
        temp_lyr = QgsVectorLayer(uri.uri(False), "inici", "postgres")
        QgsProject.instance().addMapLayer(temp_lyr)
        
        
        #    9. Seleccio dels N-camins mÃ©s proxims al domicili indicat per tal de presentar els resultats
        #    en el quadre de la interficie del modul
        '''
        try:
            limit = self.getLimit()
        except Exception as ex:
            print ("Error getLimit")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            QMessageBox.information(None, "Error", "Error getLimit")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.dlg.setEnabled(True)
            return
        if self.dlg.tabWidget_Destino.currentIndex() == 0:
            select = 'select e."'+ nomCamp[0][0] +'" as NomEntitat, r.agg_cost as Cost, r.entitatID from "Resultat" r  join "' + self.dlg.comboCapaDesti.currentText() + '" e on r.entitatID = e.id where  r.edge = -1 order by 2 asc limit ' + str(limit) + ';'
        else:
            select = 'select e."'+ nomCamp[0][0] +'" as NomEntitat, r.agg_cost as Cost, r.entitatID from "Resultat" r  join "LayerExportat'+Fitxer+'" e on r.entitatID = e.id where  r.edge = -1 order by 2 asc limit ' + str(limit) + ';'
        try:
            cur.execute(select)
            vec = cur.fetchall()
            conn.commit()
        except Exception as ex:
            print ("Error SELECT resultats")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            QMessageBox.information(None, "Error", "Error SELECT resultats")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.dlg.setEnabled(True)
            return
        
            
        '''
        #    10. Drop i Create d'una sentencia SQL per obtenir els trams junts per a cada camÃ­ optim escollit
        #     i al mateix temps, s'afegeix la informaciÃ³ obtinguda en el select anterior.
        '''
        createTrams = 'drop table if exists "TramsNous_'+Fitxer+'";\n'
        createTrams += 'create table "TramsNous_'+Fitxer+'" as select * from (\n' 
        rowCount = self.dlg.taulaResultat.rowCount()
        self.dlg.taulaResultat.setColumnCount(2)
        self.dlg.taulaResultat.setHorizontalHeaderLabels(['Entitat', lbl_Cost])
        if self.dlg.comboCost.currentText() == 'Distancia':
            rnd = 0
        else:
            rnd = 1
        for x in range (rowCount,len(vec)):
            self.dlg.taulaResultat.insertRow(x)
            self.dlg.taulaResultat.setItem(x, 0, QTableWidgetItem(str(vec[x][0])))
            self.dlg.taulaResultat.setItem(x, 1, QTableWidgetItem(str(round(vec[x][1],rnd))))
            if x < len(vec) and x >= 1:
                createTrams += 'UNION\n'
                
            createTrams += 'select entitatid, \'' + str(vec[x][0].replace("'","''")) +'\' as "NomEntitatDesti" ,'+str(round(vec[x][1],rnd))+' as agg_cost, ST_Union(newedge) as geom from "Resultat" where entitatid = '+str(vec[x][2])+' group by entitatid\n'
        
        createTrams += ")total order by agg_cost asc;"
        QApplication.processEvents()
        
        '''
        #    10.1 ExecuciÃ³ de la sentencia SQL per crear la taula amb els trams
        '''
        try:
            cur.execute(createTrams)
            conn.commit()
        except Exception as ex:
            print ("Error CREATE trams")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            QMessageBox.information(None, "Error", "Error CREATE trams")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.dlg.setEnabled(True)
            return
        
            
        '''
        #    11. PresentaciÃ³ per pantalla dels diferents camins
        #    Primer es fa la connexio amb el servei per poder presentar les dades a pantalla
        '''            
        uri = QgsDataSourceUri()
        try:
            uri.setConnection(host1,port1,nomBD1,usuari1,contra1)
        except Exception as ex:
            print ("Error a la connexio")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            QMessageBox.information(None, "Error", "Error a la connexio")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.dlg.setEnabled(True)
            return
        
        '''
        #   11.1 Es fa la selecciÃ³ de les dades que es volen presentar
        '''
        sql_total = 'select row_number() OVER() AS "id",* from "TramsNous_'+Fitxer+'"'
        QApplication.processEvents()
        uri.setDataSource("","("+sql_total+")","geom","","entitatid")
        QApplication.processEvents()
        
        try:
            cur.execute(sql_total)
            resultat = cur.fetchall()
        except Exception as ex:
            print ("Error SELECT CAMP NOM Etiquetes")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            QMessageBox.information(None, "Error", "Error SELECT CAMP NOM Etiquetes")
            conn.rollback()
            self.eliminaTaulesCalcul(Fitxer)
            self.dlg.setEnabled(True)
            return
        
        '''
        #    11.2 Es prepara el titol de la capa que apareixerÃ  a la llegenda
        '''
        if self.dlg.tabWidget_Destino.currentIndex() == 0:
            titol=self.dlg.comboCapaDesti.currentText()
        else:
            titol=self.dlg.comboLeyenda.currentText()
        titol2='Camins mÃ©s propers a '
        titol3=titol2.encode('utf8','strict')+titol.encode('utf8','strict')
        vlayer = QgsVectorLayer(uri.uri(False), titol3.decode('utf8'), "postgres")
        QApplication.processEvents()

        if vlayer.isValid():
            crs = vlayer.dataProvider().sourceCrs()
            
            vlayer_temp = QgsVectorLayer("LineString", titol3.decode('utf8'), "memory")
            vlayer_temp.setCrs(crs)
            vlayer_temp.dataProvider().addAttributes(vlayer.fields())
            vlayer_temp.updateFields()
            vlayer_temp.dataProvider().addFeatures(vlayer.getFeatures())

            symbols = vlayer_temp.renderer().symbols(QgsRenderContext())
            symbol=symbols[0]
            
            '''Es prepara cada camÃ­ de la capa amb diferent color i gruix en funcio de la distÃ ncia a la que estigui de l'origen '''
            GradSymMin = 0
            GradSymMax = limit
            GradSymNoOfClasses = limit
            GradSymInterval = round(((int(GradSymMax) - int(GradSymMin)) / float(GradSymNoOfClasses)),0)
            myRangeList = []
            gruix = 2.5
            interval = float(gruix/limit)
            
            
            for x in range (GradSymNoOfClasses):
                if x == 0:
                    min = 0
                    max = 1
                    color = QColor(0, 255, 255*x/GradSymNoOfClasses)
                elif x == (GradSymNoOfClasses - 1):
                    min = GradSymMax-1
                    max = GradSymMax
                    color =  QColor(255*x/GradSymNoOfClasses, 0, 0)
                else:
                    min = int(GradSymMin)+(GradSymInterval*x)+0.001
                    max = int(GradSymMin)+GradSymInterval*(x+1)
                    color = QColor(255*x/GradSymNoOfClasses, 255-(255*x/GradSymNoOfClasses), 0)
                
                label = str(resultat[x][0]) + ". " +str(resultat[x][2])                    
                symbol=QgsLineSymbol()

                registry = QgsSymbolLayerRegistry()
                lineMeta = registry.symbolLayerMetadata("SimpleLine")
                #Line layer
                lineLayer = lineMeta.createSymbolLayer({'width': '1', 'color': '255,0,0', 'offset': '0', 'penstyle': 'solid', 'use_custom_dash': '0', 'joinstyle': 'bevel', 'capstyle': 'round'})

                symbol.deleteSymbolLayer(0)
                symbol.appendSymbolLayer(lineLayer)

                symbol.setWidth(gruix)
                symbol.setColor(color)                
                
                ranger = QgsRendererRange(min, max, symbol, label)
                myRangeList.append(ranger)
                gruix -= float(interval)

            '''Es renderitzen els estils de cada cami'''
            fieldname="id"
            format = QgsRendererRangeLabelFormat()
            
            '''S'apliquen els estils a la capa'''
            renderer = QgsGraduatedSymbolRenderer(fieldname,myRangeList)           
            renderer.setLabelFormat(format,False) #Si en algÃºn momento hay problema con el texto de los sÃ­mbolos mostrados en leyenda, podrÃ­a estar relacionado con este booleano
            vlayer_temp.setRenderer(renderer)
            QApplication.processEvents()

            
            QgsProject.instance().addMapLayer(vlayer_temp,False)
            root = QgsProject.instance().layerTreeRoot()
            myLayerNode=QgsLayerTreeLayer(vlayer_temp)
            root.insertChildNode(0,myLayerNode)
            myLayerNode.setCustomProperty("showFeatureCount", False)
            QApplication.processEvents()
            iface.mapCanvas().refresh()
            ''''S'afegeix la capa a la pantalla'''
            #iface.legendInterface().refreshLayerSymbology(vlayer)
        else:
            QMessageBox.information(None, "LAYER ERROR 1:", "%s\n\nThe layer %s is not valid" % ("error","nom_layer"))
            
        '''
        #    12. S'afegeixen els punts de destÃ­ a pantalla amb les corresponents etiquetes amb els seus noms
        #    12.1 Es seleccionen les dades que es vol mostrar
        '''
        sql_total = 'select row_number() OVER(order by t."agg_cost") AS "id",n.entitatid, n.geom, t."NomEntitatDesti" as "NomEntitat" from "TramsNous_'+Fitxer+'" t join NecessaryPoints_'+Fitxer+' n on n.entitatid = t.entitatid order by t."agg_cost" ASC'
        QApplication.processEvents()
        uri.setDataSource("","("+sql_total+")","geom","","id")
        QApplication.processEvents()

        '''
        #    12.2 Es prepara el titol de la capa que apareixerÃ  a la llegenda
        '''
        if self.dlg.tabWidget_Destino.currentIndex() == 0:
            titol=self.dlg.comboCapaDesti.currentText()
        else:
            titol=self.dlg.comboLeyenda.currentText()
        titol2='Entitats de destÃ­ '
        titol3=titol2.encode('utf8','strict')+titol.encode('utf8','strict')
        vlayer = QgsVectorLayer(uri.uri(False), titol3.decode('utf8'), "postgres")
        QApplication.processEvents()
        '''
        #    12.3 Si la capa Ã©s vÃ lida, es carrega en SHAPE en un arxiu temporal
        '''
        if vlayer.isValid():

            crs = vlayer.dataProvider().crs()
            vlayer_temp = QgsVectorLayer("Point", titol3.decode('utf8'), "memory")
            vlayer_temp.setCrs(crs)
            vlayer_temp.dataProvider().addAttributes(vlayer.fields())
            vlayer_temp.updateFields()
            vlayer_temp.dataProvider().addFeatures(vlayer.getFeatures())

            #vlayer.setLayerTransparency(50)
            symbols = vlayer_temp.renderer().symbols(QgsRenderContext())
            symbol=symbols[0]
            symbol.setColor(QColor.fromRgb(250,50,250))
            '''S'afegeixen totes les propietats a la capa: color, tipus de font de l'etiqueta, colocacio, nom del camp a mostrar, etc'''

            layer_settings  = QgsPalLayerSettings()
            text_format = QgsTextFormat()
            
            text_format.setFont(QFont("Arial", 16))
            text_format.setSize(16)
            
            buffer_settings = QgsTextBufferSettings()
            buffer_settings.setEnabled(True)
            buffer_settings.setSize(1)
            buffer_settings.setColor(QColor("white"))
            
            text_format.setBuffer(buffer_settings)
            layer_settings.setFormat(text_format)
            
            layer_settings.isExpression = True
            layer_settings.fieldName = "concat( id,'. ',NomEntitat)"
            layer_settings.placement = QgsPalLayerSettings.AroundPoint
            layer_settings.scaleVisibility = True
            layer_settings.minimumScale = 20000
            layer_settings.maximumScale = 3000
            
            layer_settings.enabled = True
            
            layer_settings = QgsVectorLayerSimpleLabeling(layer_settings)
            vlayer_temp.setLabelsEnabled(True)
            vlayer_temp.setLabeling(layer_settings)
            vlayer_temp.triggerRepaint()
            QApplication.processEvents()
            QgsProject.instance().addMapLayer(vlayer_temp,False)
            root = QgsProject.instance().layerTreeRoot()
            myLayerNode=QgsLayerTreeLayer(vlayer_temp)
            root.insertChildNode(0,myLayerNode)
            myLayerNode.setCustomProperty("showFeatureCount", False)
            QApplication.processEvents()
            ''''S'afegeix la capa a la pantalla'''
            iface.mapCanvas().refresh()
            #qgis.utils.iface.legendInterface().refreshLayerSymbology(vlayer)
        else:
            QMessageBox.information(None, "LAYER ERROR 2:", "%s\n\nThe layer %s is not valid" % ("error","nom_layer"))
            
        '''
        #    13. S'afegeix el punt d'origen a pantalla
        #    13.1 Es selecciona la dada que es vol mostrar
        '''
        sql_total = 'select pid, geom from NecessaryPoints_'+Fitxer+' where pid = 1'
        QApplication.processEvents()
        uri.setDataSource("","("+sql_total+")","geom","","pid")
        QApplication.processEvents()
        
        '''
        #    13.2 Es prepara el titol de la capa que apareixerÃ  a la llegenda
        '''
        titol=self.dlg.lbl_numpol.text()
        titol2='Entitat d\'origen: '
        titol3=titol2.encode('utf8','strict')+titol.encode('utf8','strict')
        vlayer = QgsVectorLayer(uri.uri(False), titol3.decode('utf8'), "postgres")
        QApplication.processEvents()

        if vlayer.isValid():
            crs = vlayer.dataProvider().sourceCrs()
            vlayer_temp = QgsVectorLayer("Point", titol3.decode('utf8'), "memory")
            vlayer_temp.setCrs(crs)
            vlayer_temp.dataProvider().addAttributes(vlayer.fields())
            vlayer_temp.updateFields()
            vlayer_temp.dataProvider().addFeatures(vlayer.getFeatures())
            symbols = vlayer_temp.renderer().symbols(QgsRenderContext())
            symbol=symbols[0]
            '''S'afegeix el color a la nova entitat'''
            symbol.setColor(QColor.fromRgb(50,250,250))
            QgsProject.instance().addMapLayer(vlayer_temp,False)
            root = QgsProject.instance().layerTreeRoot()
            myLayerNode=QgsLayerTreeLayer(vlayer_temp)
            root.insertChildNode(0,myLayerNode)
            myLayerNode.setCustomProperty("showFeatureCount", False)
            QApplication.processEvents()
            ''''S'afegeix la capa a la pantalla'''
            iface.mapCanvas().refresh()
            #qgis.utils.iface.legendInterface().refreshLayerSymbology(vlayer)
        else:
            QMessageBox.information(None, "LAYER ERROR 3:", "%s\n\nThe layer %s is not valid" % ("error","nom_layer"))
        
        '''
        #    14. S'esborren les taules utilitzades durant el cÃ lcul
        '''

        self.eliminaTaulesCalcul(Fitxer)
  
    def eliminaTaulesCalcul(self,Fitxer):
        global cur
        global conn
        try:
            cur.execute('DROP TABLE IF EXISTS "Xarxa_Prova";\n')
            #cur.execute('DROP TABLE IF EXISTS "Resultat";\n') 
            cur.execute('DROP TABLE IF EXISTS checkNum;\n')
            cur.execute('DROP TABLE IF EXISTS "TramsNous_'+Fitxer+'";\n')
            #cur.execute('DROP TABLE IF EXISTS NecessaryPoints_'+Fitxer+';\n')
            cur.execute('DROP TABLE IF EXISTS "SegmentsFinals";\n')
            cur.execute('DROP TABLE IF EXISTS "LayerExportat'+Fitxer+'";\n')
            conn.commit()
        except Exception as ex:
            print("Error DROP final")
            template = "An exception of type {0} occurred. Arguments:\n{1!r}"
            message = template.format(type(ex).__name__, ex.args)
            print (message)
            QMessageBox.information(None, "Error", "Error DROP final")
            conn.rollback()
            self.bar.clearWidgets()
            self.dlg.Progres.setValue(0)
            self.dlg.Progres.setVisible(False)
            self.dlg.lblEstatConn.setText('Connectat')
            self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
            self.dlg.setEnabled(True)
            
            
            
    def eliminaTaula(self):
        '''
        Aquesta funciÃ³ s'encarrega de buidar el quadre on apareix el resultat del cÃ lcul
        '''
        self.dlg.taulaResultat.clear()
        columns = self.dlg.taulaResultat.columnCount()
        for z in range (0,columns):
            self.dlg.taulaResultat.removeColumn(z)
        rows = self.dlg.taulaResultat.rowCount()
        for z in range (0,rows):
            self.dlg.taulaResultat.removeRow(z)
        self.dlg.taulaResultat.setRowCount(0)
        self.dlg.taulaResultat.setColumnCount(0)
            
    
    def getLimit(self):
        '''
        Aquesta funciÃ³ s'encarrega de obtenir el lÃ­mit de camins que s'han de crear,
        ja que es pot donar el cas que N-camins si sigui major que nombre d'entitats de desti
        '''
        global cur
        global conn
        global Fitxer
        limitUsuari = self.dlg.SB_camins.value()
        if self.dlg.tabWidget_Destino.currentIndex() == 0:
            count = 'select count(*) from \"' + self.dlg.comboCapaDesti.currentText() + '\";'
        else:
            count = 'select count(*) from "LayerExportat'+Fitxer+'";'
        
        
        cur.execute(count)
        vect = cur.fetchall()
        
        if (limitUsuari > vect[0][0]):
            return vect[0][0]
        else:
            return limitUsuari
        
    def barraEstat_processant(self):
        '''Aquesta funciÃ³ canvia l'aparenÃ§a de la barra inferior a "Processant"'''
        self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: rgb(255, 125, 155)')
        self.dlg.lblEstatConn.setText("Processant...")
        QApplication.processEvents()
        
    def barraEstat_noConnectat(self):
        '''Aquesta funciÃ³ canvia l'aparenÃ§a de la barra inferior a "No connectat"'''
        self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #FFFFFF')
        self.dlg.lblEstatConn.setText('No connectat')
        QApplication.processEvents()
        
    def barraEstat_connectat(self):
        '''Aquesta funciÃ³ canvia l'aparenÃ§a de la barra inferior a "Connectat"'''
        self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #7fff7f')
        self.dlg.lblEstatConn.setText('Connectat')
        QApplication.processEvents()
        
    def barraEstat_connectant(self):
        '''Aquesta funciÃ³ canvia l'aparenÃ§a de la barra inferior a "Connectant"'''
        self.dlg.lblEstatConn.setStyleSheet('border:1px solid #000000; background-color: #ffff7f')
        self.dlg.lblEstatConn.setText('Connectant...')
        QApplication.processEvents()
        
    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        '''for action in self.actions:
            self.iface.removePluginMenu(
                self.tr('&exemple'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar'''
        for action in self.actions:
            self.iface.removePluginMenu('&CCU', action)
            self.toolbar.removeAction(action)

    def run(self):
        """Run method that performs all the real work"""
        # show the dialog
        self.estatInicial()
        self.dlg.show()
        conn=self.getConnections()
        # Run the dialog event loop
        self.populateComboBox(self.dlg.comboConnexio ,conn,'Selecciona connexiÃ³',True)
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass